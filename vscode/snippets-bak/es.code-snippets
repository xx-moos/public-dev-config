{
  "初始化axios请求代码": {
    "prefix": "axi",
    "body": [
      "import axios from 'axios';",
      "",
      "const server = axios.create({",
      "  baseURL: '/',",
      "  timeout: 1000,",
      "  headers: {",
      "    'Content-Type': 'application/json',",
      "  },",
      "});",
      "",
      "server.interceptors.request.use(",
      "  (config) => {",
      "    if (localStorage.getItem('token')) {",
      "      config.headers.Authorization = `Bearer ${localStorage.getItem('token')}`;",
      "    }",
      "",
      "    return config;",
      "  },",
      "  (error) => {",
      "    return Promise.reject(error);",
      "  },",
      ");",
      "",
      "server.interceptors.response.use(",
      "  (response) => {",
      "    return response.data;",
      "  },",
      "  (error) => {",
      "    return Promise.reject(error);",
      "  },",
      ");",
      "",
      "export default server;"
    ],
    "description": "初始化axios请求代码"
  },
  "Big.js计算函数": {
    "prefix": "nnbig",
    "body": [
      "<script src=\"https://cdn.bootcdn.net/ajax/libs/big.js/6.2.1/big.min.js\"></script>",
      "<script>",
      "    // 加",
      "    function add(a, b) {",
      "        return Big(a).plus(b).toNumber();",
      "    }",
      "",
      "    // 减",
      "    function subtract(a, b) {",
      "        return Big(a).minus(b).toNumber();",
      "    }",
      "",
      "    // 乘",
      "    function multiply(a, b) {",
      "        return Big(a).times(b).toNumber();",
      "    }",
      "",
      "    // 除",
      "    function divide(a, b) {",
      "        return Big(a).div(b).toNumber();",
      "    }",
      "",
      "    // toTixed",
      "    function toTixed(a, v = 2) {",
      "        return a.toFixed(v);",
      "    }",
      "</script>"
    ],
    "description": "Big.js计算函数"
  },
  "注释分隔符": {
    "prefix": "mm",
    "body": ["/** $1 */"],
    "description": "注释分隔符"
  },
  "commentBigBlock": {
    "prefix": "mmb",
    "body": ["/**", " * ${1:first}", " */"]
  },
  "忽略 prettier 格式化": {
    "prefix": "igp",
    "body": ["// prettier-ignore"]
  },
  "filter-js": {
    "prefix": "flj",
    "body": ["filter((val) => {$1})"],
    "description": "filter-js 版本"
  },
  "filter-typescript": {
    "prefix": "flt",
    "body": ["filter((val:any) => {$1})"],
    "description": "filter-ts 版本"
  },
  "map-js": {
    "prefix": "mpj",
    "body": ["map((it, ind) => ($1))"],
    "description": "map-js 版本"
  },
  "map-typescript": {
    "prefix": "mpt",
    "body": ["map((it: any, ind: number) => ($1))"],
    "description": "map-ts 版本"
  },
  ":any": {
    "prefix": "ta",
    "body": [": any"],
    "description": "any  ts  where"
  },
  "console JSON.stringify": {
    "prefix": "cjl",
    "body": ["console.log('$1- >:', JSON.parse(JSON.stringify($1)));", ""],
    "description": "console JSON.stringify"
  },
  "vue2的初始化模板": {
    "prefix": "nnv2",
    "body": [
      "new Vue({",
      "    el:\"#app\",",
      "    data() {",
      "        return {",
      "            ",
      "        }",
      "    },",
      "    components: {},",
      "    watch: {},",
      "    created() {",
      "        ",
      "    },",
      "    methods: {",
      "        ",
      "    },",
      "    computed: {",
      "        ",
      "    },",
      "})"
    ],
    "description": "vue2 html 的初始化模板"
  },
  "vue3的 class 初始化模板": {
    "prefix": "nnv3",
    "body": [
      "import { reactive, toRefs,  defineComponent, } from \"vue\";",
      "",
      "export default defineComponent({",
      "  name: \"$1\",",
      "  props: {",
      "    //接收父组件数据",
      "  },",
      "  components: {",
      "  },",
      "  setup(props, ctx) {",
      "    //  这里没有this,直接使用props里数据",
      "    return {};",
      "  },",
      "});"
    ],
    "description": "vue3的 class 初始化模板"
  },
  "react-useEffect带函数初始化": {
    "prefix": "ufg",
    "body": [
      "const getList = () => {",
      "     $1",
      "};",
      "",
      "useEffect(() => {",
      "    getList();",
      "}, []);"
    ],
    "description": "react-useEffect带函数初始化"
  },
  "XMLHttpRequest": {
    "prefix": "xhr",
    "body": [
      "const xhr = new XMLHttpRequest();",
      "",
      "xhr.onreadystatechange = () => {",
      "\tswitch (xhr.readyState) {",
      "\t\tcase 0:",
      "\t\t\t// UNSENT, Client has been created. open() not called yet.",
      "\t\t\tconsole.log('0 UNSENT', xhr.statusText);",
      "\t\t\tbreak;",
      "\t\tcase 1:",
      "\t\t\t// OPENED, open() has been called.",
      "\t\t\tconsole.log('1 OPENED', xhr.statusText);",
      "\t\t\tbreak;",
      "\t\tcase 2:",
      "\t\t\t// HEADERS_RECEIVED, send() has been called, and headers and status are available.",
      "\t\t\tconsole.log('2 HEADERS_RECEIVED', xhr.statusText);",
      "\t\t\tbreak;",
      "\t\tcase 3:",
      "\t\t\t// LOADING, Downloading; responseText holds partial data.",
      "\t\t\tconsole.log('3 LOADING', xhr.statusText);",
      "\t\t\tconsole.log('interactive... ' + xhr.responseText.length + ' bytes.');",
      "\t\t\tbreak;",
      "\t\tcase 4:",
      "\t\t\t// DONE, The operation is complete.",
      "\t\t\tconsole.log('4 DONE', xhr.statusText);",
      "",
      "\t\t\tconst header = xhr.getResponseHeader('Content-Type');",
      "\t\t\tconst headers = xhr.getAllResponseHeaders();",
      "",
      "\t\t\tif (xhr.status == 200 || xhr.status == 304) {",
      "\t\t\t\tvar data = xhr.responseText;",
      "\t\t\t\tconsole.log('COMPLETE!');",
      "\t\t\t\tconsole.dir(data);$0",
      "\t\t\t} else {",
      "\t\t\t\tconsole.log('Failed. HttpStatus: ' + xhr.statusText);",
      "\t\t\t}",
      "\t\t\tbreak;",
      "\t}",
      "};",
      "xhr.withCredentials = true;",
      "xhr.responseType = 'json';",
      "xhr.setRequestHeader('Content-Type', 'application/json');",
      "xhr.open('GET', '/${1:server}');",
      "xhr.send(null);",
      "\n",
      "// Properties: onreadystatechange, readyState, response, responseText, responseType, responseURL, responseXML, status, statusText, timeout, upload, withCredentials",
      "// Methods: open(), abort(), send(), setRequestHeader(), overrideMimeType(), getAllResponseHeaders(), getResponseHeader(),",
      "// Events: loadstart, progress, abort, error, load, timeout, loadend",
      "// 'Content-Type', *'application/x-www-form-urlencoded', 'text/plain', 'multipart/form-data', 'application/json'",
      "\n",
      "// xhr.responseType = ''; // *'', 'arraybuffer', 'blob', 'document', 'json', 'text'",
      "// xhr.overrideMimeType('text/xml'); // 'text/plain'",
      "// request.open(method, url[, async=true[, user=null[, password=null]]])"
    ],
    "description": "XMLHttpRequest"
  },
  "fetch full": {
    "prefix": "fetch",
    "body": [
      "fetch('${1:server}', {",
      "\tmethod: 'POST', // *GET, POST, PUT, DELETE, etc.",
      "\tmode: 'cors', // no-cors, cors, *same-origin",
      "\tcredentials: 'same-origin', // include, same-origin, *omit",
      "\tcache: 'no-cache', // *default, no-cache, reload, force-cache, only-if-cached",
      "\tredirect: 'follow', // manual, *follow, error",
      "\treferrer: 'no-referrer', // *client, no-referrer",
      "\theaders: { Accept: 'application/json', 'Content-Type': 'application/json' },",
      "\tbody: JSON.stringify(data) // must match 'Content-Type' header",
      "})",
      "\t.then(response => {",
      "\t\t// reject on network failure or if anything prevented the request from completing.",
      "\t\t// won’t reject on HTTP error status even if the response is an HTTP 404 or 500,",
      "\t\t// it will resolve normally (with ok status set to false)",
      "\t\tif (response.status >= 200 && response.status < 300) {",
      "\t\t\treturn Promise.resolve(response);",
      "\t\t}",
      "\n",
      "\t\treturn Promise.reject(new Error(response.statusText));",
      "\t})",
      "\t.then(response => response.json()) // parses response to JSON",
      "\t.then(result => {",
      "\t\t// custom error",
      "\t})",
      "\t.catch(error => {",
      "\t\t// common error",
      "\t\treturn null;",
      "\t});"
    ],
    "description": "Working with the Fetch API"
  },
  "fetch get": {
    "prefix": ["fetchget", "fg"],
    "body": [
      "fetch('${1:server}')",
      "\t.then(response => {",
      "\t\t// network failure, request prevented",
      "\t\tif (response.status >= 200 && response.status < 300) {",
      "\t\t\treturn Promise.resolve(response);",
      "\t\t}",
      "\n",
      "\t\treturn Promise.reject(new Error(response.statusText));",
      "\t})",
      "\t.then(response => response.json())",
      "\t.then(result => {",
      "\t\t// custom error",
      "\t})",
      "\t.catch(error => {",
      "\t\t// common error",
      "\t\treturn null;",
      "\t});"
    ],
    "description": "Make a GET request"
  },
  "fetch post": {
    "prefix": ["fetchpost", "fp"],
    "body": [
      "fetch('${1:server}', {",
      "\tmethod: 'POST',",
      "\tcredentials: 'include',",
      "\theaders: { Accept: 'application/json', 'Content-Type': 'application/json' },",
      "\tbody: JSON.stringify(data)",
      "})",
      "\t.then(response => {",
      "\t\t// network failure, request prevented",
      "\t\tif (response.status >= 200 && response.status < 300) {",
      "\t\t\treturn Promise.resolve(response);",
      "\t\t}",
      "\n",
      "\t\treturn Promise.reject(new Error(response.statusText));",
      "\t})",
      "\t.then(response => response.json())",
      "\t.then(result => {",
      "\t\t// custom error",
      "\t})",
      "\t.catch(error => {",
      "\t\t// common error",
      "\t\treturn null;",
      "\t});"
    ],
    "description": "Make a POST request"
  },
  "const array": {
    "prefix": "ca",
    "body": ["const ${1:feature} = [$2];"],
    "description": "const object\n"
  },
  "Array.length": {
    "prefix": ["arl", "arr.length"],
    "body": ["${1}.length;"],
    "description": "Array.length\n"
  },
  "Array.isArray()": {
    "prefix": ["isa", "Arr.isArray()"],
    "body": ["Array.isArray(${1})"],
    "description": "Array.isArray(value);\nreturn 'true' if the value is an Array; otherwise, 'false'.\n"
  },
  "Array.from(arrayLike)": {
    "prefix": ["arfr", "Arr.from()"],
    "body": ["Array.from(${1});"],
    "description": "Array.from(arrayLike);\nreturn a new Array instance, shallow-copied Array instance from an array-like or iterable object.\n"
  },
  "Array.from(arrayLike, mapFn)": {
    "prefix": ["arfr", "Arr.from()"],
    "body": ["Array.from(${1}, (${2:item}) => {\n\t${3}\n});"],
    "description": "Array.from(arrayLike[, mapFn[, thisArg]]);\n"
  },
  "Array.of(elementN)": {
    "prefix": ["arof", "Arr.of()"],
    "body": ["Array.of(${1});"],
    "description": "Array.of(elementN);\nreturn a new Array instance.\n"
  },
  "Array.prototype.at()": {
    "prefix": ["ara", "arr.at()"],
    "body": ["${1}.at(${2:index});"],
    "description": "const item = items.at(index);\nThe `at()` method takes an integer value and returns the item at that index, allowing for positive and negative integers. Negative integers count back from the last item in the array.\nReturns `undefined` if the given index can not be found.\n"
  },
  "Array.prototype.concat()": {
    "prefix": ["arc", "arr.concat()"],
    "body": ["${1:items}.concat(${2:valueN});"],
    "description": "let newArray = oldArray.concat([value1[, value2[, ...[, valueN]]]]);\nreturn a new array\n"
  },
  "Array.prototype.copyWithin()": {
    "prefix": ["arcw", "arr.copyWithin()"],
    "body": ["${1:items}.copyWithin(${2:target}, ${3:start}, ${4:end});"],
    "description": "array.copyWithin(target[, start[, end]]);\nreturn the modified array\n"
  },
  "Array.prototype.every()": {
    "prefix": ["arev", "arr.every()"],
    "body": ["${1:items}.every((${2:item}) => $3);"],
    "description": "array.every(callbackFn(element[, index[, array]])[, thisArg]);\nreturn 'true' if the callback function returns a truthy value for every array element. Otherwise, 'false'.\nreturns 'true' for any condition put on an empty array\n"
  },
  "Array.prototype.fill()": {
    "prefix": ["arfill", "arr.fill()"],
    "body": ["${1:items}.fill(${2:value}, ${3:start}, ${4:end});"],
    "description": "array.fill(value[, start[, end]]);\nreturn the modified array\n"
  },
  "Array.prototype.filter()": {
    "prefix": ["arf", "filter", "arr.filter()"],
    "body": ["${1:items}.filter((${2:item}) => $3);"],
    "description": "let newArray = array.filter(callbackFn(element[, index[, array]])[, thisArg]);\nreturn a new array\n"
  },
  "Array.prototype.find()": {
    "prefix": ["arfi", "find", "arr.find()"],
    "body": ["${1}.find((${2:item}) => $3);"],
    "description": "array.find(callbackFn[, thisArg]);\nreturn the value of the first element in the array that satisfies the provided testing function. Otherwise 'undefined' is returned.\n"
  },
  "Array.prototype.findIndex()": {
    "prefix": ["arfin", "findIndex", "arr.findIndex()"],
    "body": ["${1:items}.findIndex((${2:item}) => $3)"],
    "description": "array.findIndex(callbackFn(element[, index[, array]])[, thisArg]);\nreturn the index of the first element in the array that satisfies the provided testing function. Otherwise, it returns '-1'.\n6th edition\n"
  },
  "Array.prototype.flat()": {
    "prefix": ["arflat", "arr.flat()"],
    "body": ["${1:items}.flat();"],
    "description": "let newArray = array.flat([depth]);\nreturn a new array\n"
  },
  "Array.prototype.flatMap()": {
    "prefix": ["arflatMap", "arr.flatMap()"],
    "body": ["${1:items}.flatMap((${2:value}) => ${3:value});"],
    "description": "let newArray = array.flatMap(function callbackFn(currentValue[, index[, array]]) { }[, thisArg]);\nreturn a new array with each element being the result of the callback function and flattened to a depth of '1'.\n"
  },
  "Array.prototype.forEach(), arrow function": {
    "prefix": ["fre", "arr.forEach()"],
    "body": ["${1:items}.forEach((${2:item}) => {\n\t${3}\n});"],
    "description": "array.forEach(arrow function(currentValue));\n"
  },
  "Array.prototype.forEach(), index": {
    "prefix": ["frei", "arr.forEach()"],
    "body": ["${1:items}.forEach((${2:item}, ${3:index}) => {\n\t${4}\n});"],
    "description": "array.forEach(arrow function(currentValue, index));\n"
  },
  "Array.prototype.forEach()": {
    "prefix": ["frefn", "arr.forEach()"],
    "body": ["${1:items}.forEach(function(${2:item}) {\n\t${3}\n});"],
    "description": "array.forEach(function(currentValue);\n"
  },
  "Array.prototype.forEach(function(currentValue, index)": {
    "prefix": ["freifn", "arr.forEach()"],
    "body": ["${1:items}.forEach(function(${2:item}, ${3:index}) {\n\t${4}\n});"],
    "description": "array.forEach(function callbackFn(currentValue [, index [, array]]) { }[, thisArg]);\n"
  },
  "Array.prototype.includes()": {
    "prefix": ["ari", "arr.includes()"],
    "body": ["${1}.includes(${2:value})"],
    "description": "array.includes(valueToFind[, fromIndex]);\nreturn a Boolean value\n"
  },
  "Array.prototype.indexOf()": {
    "prefix": ["ario", "arr.indexOf()"],
    "body": ["${1:items}.indexOf(${2:item})"],
    "description": "array.indexOf(searchElement[, fromIndex]);\nreturn the first index of the element in the array; '-1' if not found.\n"
  },
  "Array.prototype.join()": {
    "prefix": ["arj", "arr.join()"],
    "body": ["${1}.join(${2:separator});"],
    "description": "array.join([separator]);\nreturn a string with all array elements joined. If array.length is 0, the empty string is returned.\n"
  },
  "Array.prototype.lastIndexOf()": {
    "prefix": ["arlio", "arr.lastIndexOf()"],
    "body": ["${1:items}.lastIndexOf(${2:item})"],
    "description": "array.lastIndexOf(searchElement[, fromIndex]);\nreturn the last index of the element in the array; '-1' if not found.\n"
  },
  "Array.prototype.map()": {
    "prefix": ["armap", "map", "arr.map()"],
    "body": ["${1}.map((${2:currentValue}) => {\n\t${3}\n});"],
    "description": "let newArray = array.map(function callbackFn(currentValue[, index[, array]]) { }[, thisArg]);\nreturn a new array with each element being the result of the callback function.\n"
  },
  "Array.prototype.pop()": {
    "prefix": ["arp", "arr.pop()"],
    "body": ["${1}.pop();"],
    "description": "array.pop();\nreturn the removed element from the array; 'undefined' if the array is empty.\n"
  },
  "Array.prototype.push()": {
    "prefix": ["arj", "arr.push()"],
    "body": ["${1}.push(${2:item});"],
    "description": "arr.push(element1[, ...[, elementN]]);\nreturn the new length of the array.\n"
  },
  "Array.prototype.reduce()": {
    "prefix": ["arred", "arr.reduce()"],
    "body": ["${1:items}.reduce((${2:previousValue}, ${3:currentValue}) => {\n\treturn ${3}\n});"],
    "description": "array.reduce(callbackFn(previousValue, currentValue[, index[, array]]), [, initialValue]);\nreturn The single value that results from the reduction.\n"
  },
  "Array.prototype.reduceRight()": {
    "prefix": ["arredr", "arr.reduceRight()"],
    "body": [
      "${1:items}.reduceRight((${2:accumulator}, ${3:currentValue}) => {\n\treturn ${4}\n});"
    ],
    "description": "array.reduceRight(callbackFn(accumulator, currentValue[, index[, array]])[, initialValue]);\nreturn the value that results from the reduction.\n"
  },
  "Array.prototype.reverse()": {
    "prefix": ["arre", "arr.reverse()"],
    "body": ["${1:items}.reverse();"],
    "description": "array.reverse();\nreturn the reversed array.\n"
  },
  "Array.prototype.shift()": {
    "prefix": ["ars", "arr.shift()"],
    "body": ["${1}.shift();"],
    "description": "array.shift();\nreturn the removed element from the array; 'undefined' if the array is empty.\n"
  },
  "Array.prototype.slice()": {
    "prefix": ["arsl", "arr.slice()"],
    "body": ["${1:items}.slice(${2:beginIndex}, ${3:endIndex});"],
    "description": "array.slice([begin[, end]]);\n return a shallow copy of a portion of an array into a new array object selected from begin to end (end not included). The original array will not be modified.\n"
  },
  "Array.prototype.some()": {
    "prefix": ["arso", "arr.some()"],
    "body": ["${1:items}.some((${2:item}) => $3);"],
    "description": "array.some(callbackFn(element[, index[, array]])[, thisArg]);\nreturn 'true' if the callback function returns a truthy value for at least one element in the array. Otherwise, 'false'.\nreturns false for any condition put on an empty array.\n"
  },
  "Array.prototype.sort()": {
    "prefix": ["arsor", "arr.sort()"],
    "body": ["${1:items}.sort((${2:firstEl}, ${3:secondEl}) => {\n\t${4}\n});"],
    "description": "array.sort([compareFunction(firstEl, secondEl)]);\nreturn the sorted array. Note that the array is sorted in-place, and no copy is made.\n"
  },
  "Array.prototype.splice()": {
    "prefix": ["arsp", "arr.splice()"],
    "body": ["${1:items}.splice(${2:startIndex}, ${3:deleteCount}${4:, ${5:item}});"],
    "description": "let arrDeletedItems = array.splice(start[, deleteCount[, item1[, item2[, ...]]]]);\nchanges the contents of an array by removing or replacing existing elements and/or adding new elements in-place.\nreturn an array containing the deleted elements,\nIf no elements are removed, an empty array is returned.\n"
  },
  "Array.prototype.unshift()": {
    "prefix": ["aru", "arr.unshift()"],
    "body": ["${1:items}.unshift(${2:item});"],
    "description": "array.unshift(element1[, ...[, elementN]])();\nreturn the new length of the array.\n"
  },
  "Array.prototype.entries()": {
    "prefix": ["are", "arr.entries()"],
    "body": ["${1:items}.entries();"],
    "description": "array.entries();\nreturn a new Array Iterator object that contains the key/value pairs for each index in the array.\n"
  },
  "Array.prototype.keys()": {
    "prefix": ["ark", "arr.keys()"],
    "body": ["${1:items}.keys();"],
    "description": "array.keys();\nreturns a new Array Iterator object that contains the keys for each index in the array.\n"
  },
  "Array.prototype.values()": {
    "prefix": ["arv", "arr.values()"],
    "body": ["${1}.values();"],
    "description": "array.values();\nreturn a new Array Iterator object that contains the values for each index in the array.\n"
  },
  "Array.prototype[@@iterator]()": {
    "prefix": ["arr.@@iterator"],
    "body": ["const ${2:iterator} = ${1:items}[Symbol.iterator]();", "$2.next().value"],
    "description": "array[Symbol.iterator]();\nThe initial value of the @@iterator property is the same function object as the initial value of the values() property.\n"
  },
  "get Array[@@species]": {
    "prefix": ["arr.@@species"],
    "body": [
      "class FeatureArray extends Array {",
      "\tstatic get [Symbol.species]() { return Array; }",
      "}"
    ],
    "description": "Array[Symbol.species]\nThe Array[@@species] accessor property returns the Array constructor.\n"
  },
  "sequence of 0..n": {
    "prefix": "seq",
    "body": ["[...Array(${1:length}).keys()]${2}"],
    "description": "sequence of 0..n\n"
  },
  "const awaited": {
    "prefix": "caw",
    "body": ["const ${1:result} = await ${2:promise};"],
    "description": "const assignment awaited\n"
  },
  "async function (named)": {
    "prefix": "asfn",
    "body": [
      "async function ${1:name}(${2:param}) {\n\tconst ${3:result} = await ${4:promise};\n\treturn ${3:result};\n}\n"
    ],
    "description": "async function named\n"
  },
  "async function (anonymous)": {
    "prefix": "asfna",
    "body": ["async function (${1:param}) {\n\t${2}\n}\n"],
    "description": "async function anonymous\n"
  },
  "async generator function (named)": {
    "prefix": "asgfn",
    "body": ["async function* ${1:name} (${2:param}) {\n\t${3}\n}\n"],
    "description": "async generator function named\n"
  },
  "async generator function (anonymous)": {
    "prefix": "asgfna",
    "body": ["async function* (${1:param}) {\n\t${2}\n}\n"],
    "description": "async generator function anonymous\n"
  },
  "async arrow function": {
    "prefix": "asaf",
    "body": ["async (${1:param}) => {\n\t${2}\n}\n"],
    "description": "async arrow function\n"
  },
  "await": {
    "prefix": "aw",
    "body": ["await ${1}"],
    "description": "await\n"
  },
  "await Promise.all": {
    "prefix": "awpa",
    "body": ["await Promise.all(${1:value})\n"],
    "description": "await Promise.all\n"
  },
  "await Promise.all.map": {
    "prefix": "awpam",
    "body": ["await Promise.all(${1:array}.map((${2:value}) => {\n\t${3}\n}))\n"],
    "description": "await Promise.all.map\n"
  },
  "alert": {
    "prefix": "wa",
    "body": ["window.alert('${1:msg}');"],
    "description": "window.alert\n"
  },
  "confirm": {
    "prefix": "wc",
    "body": ["window.confirm('${1:msg}');"],
    "description": "window.confirm\n"
  },
  "prompt": {
    "prefix": "wp",
    "body": ["window.prompt('${1:title}', '${2:defaultText}');"],
    "description": "window.prompt\n"
  },
  "setTimeOut(), arrow function": {
    "prefix": "st",
    "body": ["setTimeout(() => {", "\t${0}", "}${2:, ${3:delay}});", ""],
    "description": "setTimeOut\n"
  },
  "setTimeOut(), clearTimeout(), arrow function, ": {
    "prefix": "stctaf",
    "body": [
      "const ${1:timeout} = window.setTimeout(() => {",
      "\t${3}",
      "}, ${2:delay});",
      "",
      "window.clearTimeout(${1:timeout});"
    ],
    "description": "setTimeOut/clearTimeout\n"
  },
  "setTimeout()": {
    "prefix": "stfn",
    "body": ["setTimeout(function() {", "\t${0}", "}${2:, ${3:delay}});", ""],
    "description": "setTimeout\n"
  },
  "setTimeout(), clearTimeout()": {
    "prefix": "stctfn",
    "body": [
      "const ${1:timeout} = window.setTimeout(function() {",
      "\t${3}",
      "}, ${2:delay});",
      "",
      "window.clearTimeout(${1});"
    ],
    "description": "setTimeout/clearTimeout\n"
  },
  "setInterval(), arrow function": {
    "prefix": "si",
    "body": ["setInterval(() => {", "\t${0}", "}${2:, ${3:interval}});", ""],
    "description": "setInterval\n"
  },
  "setInterval(), clearInterval(), arrow function": {
    "prefix": "sici",
    "body": [
      "const ${1:timer} = window.setInterval(() => {",
      "\t${3}",
      "}, ${2:interval});",
      "",
      "window.clearInterval(${1});"
    ],
    "description": "setInterval/clearInterval\n"
  },
  "setInterval()": {
    "prefix": "sifn",
    "body": ["setInterval(function() {", "\t${0}", "}${2:, ${3:interval}});", ""],
    "description": "setInterval\n"
  },
  "setInterval(), clearInterval()": {
    "prefix": "sicifn",
    "body": [
      "const ${1:timer} = window.setInterval(function() {\n\t${3}\n}, ${2:interval});\n\nwindow.clearInterval(${1:timer});"
    ],
    "description": "setInterval/clearInterval\n"
  },
  "localStorage.setItem('key', 'value');": {
    "prefix": "lss",
    "body": ["localStorage.setItem('${1:key}', ${2:value});"],
    "description": "localStorage.setItem('key', 'value');\n"
  },
  "localStorage.getItem('key');": {
    "prefix": "lsg",
    "body": ["localStorage.getItem('${1:key}');"],
    "description": "localStorage.getItem('key');\n"
  },
  "localStorage.removeItem('key');": {
    "prefix": "lsr",
    "body": ["localStorage.removeItem('${1:key}');"],
    "description": "localStorage.removeItem('key');\n"
  },
  "localStorage.clear();": {
    "prefix": "lsc",
    "body": ["localStorage.clear();"],
    "description": "localStorage.clear();\n"
  },
  "window.screen.availWidth": {
    "prefix": "wsaw",
    "body": ["window.screen.availWidth"],
    "description": "window.screen.availWidth;\n"
  },
  "window.screen.availHeight": {
    "prefix": "wsah",
    "body": ["window.screen.availHeight"],
    "description": "window.screen.availHeight;\n"
  },
  "window.screen.width": {
    "prefix": "wsw",
    "body": ["window.screen.width"],
    "description": "window.screen.width;\n"
  },
  "window.screen.height": {
    "prefix": "wsh",
    "body": ["window.screen.height"],
    "description": "window.screen.height;\n"
  },
  "window.location.href": {
    "prefix": "wlh",
    "body": ["window.location.href"],
    "description": "window.location.href\n"
  },
  "window.location.hostname": {
    "prefix": "wlhn",
    "body": ["window.location.hostname"],
    "description": "window.location.hostname\n"
  },
  "window.location.pathname": {
    "prefix": "wlp",
    "body": ["window.location.pathname"],
    "description": "window.location.pathname\n"
  },
  "window.location.protocol": {
    "prefix": "wlpr",
    "body": ["window.location.protocol"],
    "description": "window.location.protocol\n"
  },
  "window.location.assign()": {
    "prefix": "wls",
    "body": ["window.location.assign(${1:url})"],
    "description": "window.location.assign()\n"
  },
  "window.history.back()": {
    "prefix": "whb",
    "body": ["window.history.back();"],
    "description": "window.history.back()\n"
  },
  "window.history.forward()": {
    "prefix": "whf",
    "body": ["window.history.forward();"],
    "description": "window.history.forward()\n"
  },
  "window.navigator.language": {
    "prefix": "wnl",
    "body": ["window.navigator.language"],
    "description": "window.navigator.language\n"
  },
  "window.navigator.languages": {
    "prefix": "wnls",
    "body": ["window.navigator.languages"],
    "description": "window.navigator.languages\n"
  },
  "window.navigator.userAgent": {
    "prefix": "wnu",
    "body": ["window.navigator.userAgent"],
    "description": "window.navigator.userAgent\n"
  },
  "typeof": {
    "prefix": "to",
    "body": ["typeof ${1:operand} === '${2:undefined}'"],
    "description": "typeof\n"
  },
  "typeof is undefined": {
    "prefix": "tou",
    "body": ["typeof ${1:operand} === 'undefined'"],
    "description": "Type is Undefined\n"
  },
  "typeof is function": {
    "prefix": "tof",
    "body": ["typeof ${1:operand} === 'function'"],
    "description": "Type is Function\n"
  },
  "typeof is symbol": {
    "prefix": "tosy",
    "body": ["typeof ${1:operand} === 'symbol'"],
    "description": "Type is Symbol\n"
  },
  "typeof is string": {
    "prefix": "tos",
    "body": ["typeof ${1:operand} === 'string'"],
    "description": "Type is String\n"
  },
  "typeof is number": {
    "prefix": "ton",
    "body": ["typeof ${1:operand} === 'number'"],
    "description": "Type is Number\n"
  },
  "typeof is boolean": {
    "prefix": "tob",
    "body": ["typeof ${1:operand} === 'boolean'"],
    "description": "Type is Boolean\n"
  },
  "typeof is bigint": {
    "prefix": "tobi",
    "body": ["typeof ${1:operand} === 'bigint'"],
    "description": "Type is Bigint\n"
  },
  "instanceof": {
    "prefix": "io",
    "body": ["${1:object} instanceof ${2:Constructor}"],
    "description": "instanceof\nThe `instanceof` operator tests to see if the `prototype` property of a constructor appears anywhere in the prototype chain of an object. \nthe `prototype` actually defines the type, not the constructor function."
  },
  "JSON.parse()": {
    "prefix": "jp",
    "body": ["JSON.parse(${1:obj})"],
    "description": "JSON.parse()\n"
  },
  "JSON.stringify()": {
    "prefix": "js",
    "body": ["JSON.stringify(${1:obj})"],
    "description": "JSON.stringify()\n"
  },
  "try/catch": {
    "prefix": "tc",
    "body": ["try {\n\t${1}\n} catch (${2:error}) {\n\t\n}"],
    "description": "try/catch\n"
  },
  "try/catch/finally": {
    "prefix": "tcf",
    "body": ["try {\n\t${1}\n} catch (${2:error}) {\n\t\n} finally {\n\t\n}"],
    "description": "try/catch/finally\n"
  },
  "try/finally": {
    "prefix": "tf",
    "body": ["try {\n\t${1}\n} finally {\n\t\n}"],
    "description": "try/finally\n"
  },
  "return": {
    "prefix": "r",
    "body": ["return ${1}"],
    "description": "return\n"
  },
  "return null": {
    "prefix": "rn",
    "body": ["return null;"],
    "description": "return null\n"
  },
  "return this": {
    "prefix": "rt",
    "body": ["return this;"],
    "description": "return this\n"
  },
  "return new object": {
    "prefix": "ro",
    "body": ["return {\n\t${0}\n};"],
    "description": "return new object\n"
  },
  " 三元 运算符": {
    "prefix": "tif",
    "body": ["${1} ? ${2} : ${3};"],
    "description": "ternary operator\n 三元 运算符"
  },
  "debugger": {
    "prefix": ["de", "bug"],
    "body": ["debugger;"],
    "description": "debugger\n"
  },
  "encodeURI(URI)": {
    "prefix": "eu",
    "body": ["encodeURI(${1:URI})"],
    "description": "encodeURI(URI)\nencodes a Uniform Resource Identifier (URI) by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two 'surrogate' characters).\nnew string representing the provided string encoded as a Uniform Resource Identifier (URI).\n"
  },
  "decodeURI(encodedURI)": {
    "prefix": "du",
    "body": ["decodeURI(${1:encodedURI})"],
    "description": "decodeURI(encodedURI)\ndecodes a Uniform Resource Identifier (URI) previously created by encodeURI() or by a similar routine.\nreturn a new string representing the unencoded version of the given encoded Uniform Resource Identifier (URI).\nthrows an URIError ('malformed URI sequence') exception when encodedURI contains invalid character sequences."
  },
  "encodeURIComponent(str)": {
    "prefix": "euc",
    "body": ["encodeURIComponent(${1:str})"],
    "description": "encodeURIComponent(str)\nencodes a Uniform Resource Identifier (URI) component by replacing each instance of certain characters by one, two, three, or four escape sequences representing the UTF-8 encoding of the character (will only be four escape sequences for characters composed of two 'surrogate' characters).\nreturn a new string representing the provided string encoded as a Uniform Resource Identifier (URI) component."
  },
  "decodeURIComponent(encodedURI)": {
    "prefix": "duc",
    "body": ["decodeURIComponent(${1:encodedURI})"],
    "description": "decodeURIComponent(encodedURI)\ndecodes a Uniform Resource Identifier (URI) component previously created by encodeURIComponent or by a similar routine.\nthrows an URIError ('malformed URI sequence') exception when used wrongly.\n"
  },
  "class": {
    "prefix": "cl",
    "body": ["class ${1:ClassName} {", "\tconstructor(${2:param}) {", "\t\t${3}", "\t}", "", "}"],
    "description": "class\n"
  },
  "class extends": {
    "prefix": "cle",
    "body": [
      "class ${1:ClassName} extends ${2:BaseClassName} {",
      "\tconstructor(${3:param}) {",
      "\t\tsuper();",
      "\t\t${4}",
      "\t}",
      "",
      "}"
    ],
    "description": "class extends\n"
  },
  "class property": {
    "prefix": ["clp"],
    "body": ["${1:property} = ${2:value};"],
    "description": "class property\n"
  },
  "class method()": {
    "prefix": ["m", "clm"],
    "body": ["${1:method} (${2:param}) {", "\t${3}", "}"],
    "description": "method statements\n"
  },
  "class static method()": {
    "prefix": ["clsm", "staticMethod"],
    "body": ["static ${1:methodName}(${2:param}) {", "\treturn ${3};", "}"],
    "description": "class static method\n"
  },
  "class static property": {
    "prefix": ["clsp", "staticProperty"],
    "body": ["static ${1:property} = ${2:value};"],
    "description": "class static property\n"
  },
  "class private method()": {
    "prefix": ["clpm", "privateMethod"],
    "body": ["#${1:methodName}(${2:param}) {", "\treturn ${3};", "}"],
    "description": "class private method\n"
  },
  "class private property": {
    "prefix": ["clpp", "privateProperty"],
    "body": ["#${1:property} = ${2:value};"],
    "description": "class private property\n"
  },
  "class static private method()": {
    "prefix": ["clspm", "staticPrivateMethod"],
    "body": ["static #${1:methodName}(${2:param}) {", "\treturn ${3};", "}"],
    "description": "class static private method\n"
  },
  "class static private property": {
    "prefix": ["clspp", "staticPrivateProperty"],
    "body": ["static #${1:property} = ${2:value};"],
    "description": "class static private property\n"
  },
  "class generator method()": {
    "prefix": ["clgm", "generatorMethod"],
    "body": ["*${1:methodName}(${2:param}) {", "\tyield ${3};", "}"],
    "description": "class static\n"
  },
  "class constructor()": {
    "prefix": ["clc", "cons"],
    "body": ["constructor(${1:param}) {\n\t${2}\n}"],
    "description": "class constructor\n"
  },
  "get property()": {
    "prefix": "get",
    "body": ["get ${1:propertyName} () {", "\treturn this.${2:element};", "}"],
    "description": "getter\n"
  },
  "set property()": {
    "prefix": "set",
    "body": ["set ${1:propertyName} (${2:value}) {", "\tthis.${3:element} = ${2};", "}"],
    "description": "setter\n"
  },
  "getter() and setter()": {
    "prefix": "gs",
    "body": [
      "get ${1:propertyName} () {",
      "\treturn this.${2:element};",
      "}",
      "",
      "set ${1} (${3:value}) {",
      "\tthis.${2:element} = ${3};",
      "}"
    ],
    "description": "getter and setter\n"
  },
  "async method()": {
    "prefix": "asm",
    "body": ["async ${1:method}(${2:param}) {", "\t${3}", "}"],
    "description": "async method\n"
  },
  "prototype constructor()": {
    "prefix": ["pc", "protoc"],
    "body": ["const ${1:Constructor} = function(${2:param}) {", "\t${3}", "};"],
    "description": "prototypal constructor\n"
  },
  "prototype method()": {
    "prefix": ["pm", "protom"],
    "body": ["${1:Constructor}.prototype.${2:method} = function (${3:param}) {", "\t${4}", "};"],
    "description": "prototype method\n"
  },
  "module as class (CommonJS)": {
    "prefix": "ec",
    "body": [
      "class ${1:name} {\n\tconstructor (${2:param}) {\n\t\t${3}\n\t}\n}\n\nmodule.exports = ${1:name}\n"
    ],
    "description": "exports.member (CommonJS)\n"
  },
  "exports.member (CommonJS)": {
    "prefix": "em",
    "body": ["exports.${1:member} = ${2:value}"],
    "description": "exports.member (CommonJS)\n"
  },
  "module.exports (CommonJS)": {
    "prefix": "me",
    "body": ["module.exports = ${1:name}"],
    "description": "module.exports (CommonJS)\n"
  },
  "require (CommonJS)": {
    "prefix": "rq",
    "body": ["require('${1:module}')"],
    "description": "require (CommonJS)\n"
  },
  "require assignment (CommonJS)": {
    "prefix": "crq",
    "body": ["const ${1:module} = require('${1:module}');"],
    "description": "require assignment (CommonJS)\n"
  },
  "use strict": {
    "prefix": "usm",
    "body": ["'use strict';"],
    "description": "use strict mode\n"
  },
  "const": {
    "prefix": "c",
    "body": ["const ${1:name} = ${2:value};"],
    "description": "const assignment\n"
  },
  "const object": {
    "prefix": "co",
    "body": ["const ${1:feature} = {\n\t$2\n};"],
    "description": "const object\n"
  },
  "const string": {
    "prefix": "cs",
    "body": ["const ${1:feature} = '$2';"],
    "description": "const string\n"
  },
  "const destructing object": {
    "prefix": "cdo",
    "body": ["const {${2}} = ${1};"],
    "description": "const assignment destructuring\n"
  },
  "const destructing array": {
    "prefix": "cda",
    "body": ["const [${2}] = ${1};"],
    "description": "const assignment destructuring\n"
  },
  "let": {
    "prefix": "l",
    "body": ["let ${1:name} = ${2:value};"],
    "description": "let assignment\n"
  },
  "let object": {
    "prefix": "lo",
    "body": ["let ${1:feature} = {\n\t$2\n};"],
    "description": "let object\n"
  },
  "let array": {
    "prefix": "la",
    "body": ["let ${1:feature} = [$2];"],
    "description": "let object\n"
  },
  "let string": {
    "prefix": "ls",
    "body": ["let ${1:feature} = '$2';"],
    "description": "let string\n"
  },
  "let destructing object": {
    "prefix": "ldo",
    "body": ["let {${2}} = ${1};"],
    "description": "let assignment destructuring\n"
  },
  "let destructing array": {
    "prefix": "lda",
    "body": ["let [${2}] = ${1};"],
    "description": "let assignment destructuring\n"
  },
  "var": {
    "prefix": "v",
    "body": ["var ${1:name} = ${2:value};"],
    "description": "var assignment\n"
  },
  "var object": {
    "prefix": "vo",
    "body": ["var ${1:feature} = {\n\t$2\n};"],
    "description": "var object\n"
  },
  "var array": {
    "prefix": "va",
    "body": ["var ${1:feature} = [$2];"],
    "description": "var object\n"
  },
  "var string": {
    "prefix": "vs",
    "body": ["var ${1:feature} = '$2';"],
    "description": "var string\n"
  },
  "var destructing object": {
    "prefix": "vdo",
    "body": ["var {${2}} = ${1};"],
    "description": "var destructuring assignment\n"
  },
  "var destructing array": {
    "prefix": "vda",
    "body": ["var [${2}] = ${1};"],
    "description": "var destructuring assignment\n"
  },
  "destructuring parameter": {
    "prefix": "dp",
    "body": ["{${0}}: ${1:parameter}"],
    "description": "destructuring parameter\n"
  },
  "property object": {
    "prefix": "po",
    "body": ["${1:property}: {\n\t${2:property},\n},$0"],
    "description": "object property\n"
  },
  "property array": {
    "prefix": "pa",
    "body": ["${1:property}: [${2:item}],$0"],
    "description": "array property\n"
  },
  "property string": {
    "prefix": "ps",
    "body": ["${1:property}: '${2:value}',$0"],
    "description": "string property\n"
  },
  "Node.compareDocumentPosition()": {
    "prefix": ["cdp", "dom.compareDocumentPosition"],
    "body": ["const ${3:compareMask} = ${1:node}.compareDocumentPosition(${2:otherNode});"],
    "description": "Compares the position of the current node against another node in any other document.\n"
  },
  "Node.cloneNode()": {
    "prefix": ["cn", "dom.cloneNode"],
    "body": ["const ${2:newClone} = ${1:node}.cloneNode(true);"],
    "description": "Clone a Node, and optionally, all of its contents.\n"
  },
  "Node.contains()": {
    "prefix": ["con", "dom.contains"],
    "body": ["${1:node}.contains(${2:otherNode});"],
    "description": "Returns a Boolean value indicating whether or not a node is a descendant of the calling node.\n"
  },
  "Node.hasChildNodes()": {
    "prefix": ["hcn", "dom.hasChildNodes"],
    "body": ["${1:node}.hasChildNodes()"],
    "description": "The `Node.hasChildNodes()` method returns a Boolean value indicating whether the given Node has child nodes or not.\n"
  },
  "Element.matches()": {
    "prefix": ["matches", "dom.matches"],
    "body": ["${1:element}.matches('${2:selectorString}')"],
    "description": "Returns a Boolean indicating whether or not the element would be selected by the specified selector string.\n"
  },
  "Document.createDocumentFragment": {
    "prefix": ["cdf", "dom.createDocumentFragment"],
    "body": ["${1:document}.createDocumentFragment();$2"],
    "description": "Creates a new document fragment.\n"
  },
  "Document.createElement": {
    "prefix": ["cel", "dom.createElement"],
    "body": ["${1:document}.createElement('${2:tagName}');"],
    "description": "Creates a new element with the given tag name.\n"
  },
  "Document.createTextNode": {
    "prefix": ["ctn", "dom.createTextNode"],
    "body": ["${1:document}.createTextNode(${2:data});"],
    "description": "Creates a text node.\n"
  },
  "Element.classList.add()": {
    "prefix": ["cla", "dom.classList.add"],
    "body": ["${1:element}.classList.add('${2:className}');"],
    "description": "DOMTokenList.add(token0, token1, /* ... ,*/ tokenN);\n"
  },
  "Element.classList.contains()": {
    "prefix": ["clc", "dom.classList.contains"],
    "body": ["${1:element}.classList.contains('${2:className}');"],
    "description": "DOMTokenList.contains(token);\n"
  },
  "Element.classList.replace()": {
    "prefix": ["clrp", "dom.classList.replace"],
    "body": ["${1:element}.classList.replace('${2:oldToken}', '${3:newToken}');"],
    "description": "DOMTokenList.replace(oldToken, newToken);\n"
  },
  "Element.classList.remove()": {
    "prefix": ["clr", "dom.classList.remove"],
    "body": ["${1:element}.classList.remove('${2:className}');"],
    "description": "DOMTokenList.remove(token0, token1, /* ... ,*/ tokenN);\n"
  },
  "Element.classList.toggle()": {
    "prefix": ["clt", "dom.classList.toggle"],
    "body": ["${1:element}.classList.toggle('${2:className}');"],
    "description": "DOMTokenList.toggle(token, force);\n"
  },
  "Element.getClientRects()": {
    "prefix": ["gcr", "dom.getClientRects"],
    "body": ["const ${3:rectCollection} = ${1:element}.getClientRects();"],
    "description": "The getClientRects() method of the Element interface returns a collection of DOMRect objects that indicate the bounding rectangles for each CSS border box in a client.\n"
  },
  "Element.getBoundingClientRect()": {
    "prefix": ["gbcr", "dom.getBoundingClientRect"],
    "body": ["const ${3:domRect} = ${1:element}.getBoundingClientRect();"],
    "description": "The `Element.getBoundingClientRect()` method returns the size of an element and its position relative to the viewport.\n"
  },
  "Element.scroll()": {
    "prefix": ["scroll", "dom.scroll"],
    "body": ["${1:element}.scroll({top: ${2:top}, left: ${3:left}, behavior: 'smooth'});"],
    "description": "The scroll() method of the Element interface scrolls the element to a particular set of coordinates inside a given element.\n"
  },
  "Element.scrollBy()": {
    "prefix": ["scrollBy", "dom.scrollBy"],
    "body": ["${1:element}.scrollBy({top: ${2:top}, left: ${3:left}, behavior: 'smooth'});"],
    "description": "The scrollBy() method of the Element interface scrolls an element by the given amount.\n"
  },
  "Element.scrollTo()": {
    "prefix": ["scrollTo", "dom.scrollTo"],
    "body": ["${1:element}.scrollTo({top: ${2:top}, left: ${3:left}, behavior: 'smooth'});"],
    "description": "The scrollTo() method of the Element interface scrolls to a particular set of coordinates inside a given element.\n"
  },
  "Element.scrollIntoView()": {
    "prefix": ["scrollIntoView", "dom.scrollIntoView"],
    "body": ["${1:element}.scrollIntoView({behavior: 'smooth'});"],
    "description": "The Element interface's scrollIntoView() method scrolls the element's parent container such that the element on which scrollIntoView() is called is visible to the user\n"
  },
  "Element.clientWidth": {
    "prefix": ["clientWidth", "dom.clientWidth"],
    "body": ["${1:element}.clientWidth"],
    "description": "The Element.clientWidth property is zero for inline elements and elements with no CSS; otherwise, it's the inner width of an element in pixels. It includes padding but excludes borders, margins, and vertical scrollbars (if present).\n"
  },
  "Element.clientHeight": {
    "prefix": ["clientHeight", "dom.clientHeight"],
    "body": ["${1:element}.clientHeight"],
    "description": "The Element.clientHeight read-only property is zero for elements with no CSS or inline layout boxes; otherwise, it's the inner height of an element in pixels. It includes padding but excludes borders, margins, and horizontal scrollbars (if present).\n"
  },
  "Element.clientLeft": {
    "prefix": ["clientLeft", "dom.clientLeft"],
    "body": ["${1:element}.clientLeft"],
    "description": "The width of the left border of an element in pixels. It includes the width of the vertical scrollbar if the text direction of the element is right–to–left and if there is an overflow causing a left vertical scrollbar to be rendered. clientLeft does not include the left margin or the left padding. clientLeft is read-only.\n"
  },
  "Element.clientTop": {
    "prefix": ["clientTop", "dom.clientTop"],
    "body": ["${1:element}.clientTop"],
    "description": "The width of the top border of an element in pixels. It is a read-only, integer property of element.\n"
  },
  "Element.scrollWidth": {
    "prefix": ["scrollWidth", "dom.scrollWidth"],
    "body": ["${1:element}.scrollWidth"],
    "description": "The Element.scrollWidth read-only property is a measurement of the width of an element's content, including content not visible on the screen due to overflow.\n"
  },
  "Element.scrollHeight": {
    "prefix": ["scrollHeight", "dom.scrollHeight"],
    "body": ["${1:element}.scrollHeight"],
    "description": "The Element.scrollHeight read-only property is a measurement of the height of an element's content, including content not visible on the screen due to overflow.\n"
  },
  "Element.scrollLeft": {
    "prefix": ["scrollLeft", "dom.scrollLeft"],
    "body": ["${1:element}.scrollLeft"],
    "description": "The Element.scrollLeft property gets or sets the number of pixels that an element's content is scrolled from its left edge.\n"
  },
  "Element.scrollTop": {
    "prefix": ["scrollTop", "dom.scrollTop"],
    "body": ["${1:element}.scrollTop"],
    "description": "The Element.scrollTop property gets or sets the number of pixels that an element's content is scrolled vertically.\n"
  },
  "HTMLElement.offsetWidth": {
    "prefix": ["offsetWidth", "dom.offsetWidth"],
    "body": ["${1:HTMLElement}.offsetWidth"],
    "description": "The HTMLElement.offsetWidth read-only property returns the layout width of an element as an integer.\n"
  },
  "HTMLElement.offsetHeight": {
    "prefix": ["offsetHeight", "dom.offsetHeight"],
    "body": ["${1:HTMLElement}.offsetHeight"],
    "description": "The HTMLElement.offsetHeight read-only property returns the height of an element, including vertical padding and borders, as an integer.\n"
  },
  "HTMLElement.offsetTop": {
    "prefix": ["offsetTop", "dom.offsetTop"],
    "body": ["${1:HTMLElement}.offsetTop"],
    "description": "The HTMLElement.offsetTop read-only property returns the distance of the current element relative to the top of the offsetParent node.\n"
  },
  "HTMLElement.offsetLeft": {
    "prefix": ["offsetLeft", "dom.offsetLeft"],
    "body": ["${1:HTMLElement}.offsetLeft"],
    "description": "The HTMLElement.offsetLeft read-only property returns the number of pixels that the upper left corner of the current element is offset to the left within the HTMLElement.offsetParent node.\n"
  },
  "HTMLElement.offsetParent": {
    "prefix": ["offsetParent", "dom.offsetParent"],
    "body": ["${1:HTMLElement}.offsetParent"],
    "description": "The HTMLElement.offsetParent read-only property returns a reference to the element which is the closest (nearest in the containment hierarchy) positioned ancestor element. If there is no positioned ancestor element, the nearest ancestor td, th, table will be returned, or the body if there are no ancestor table elements either.\n"
  },
  "Document.createAttribute": {
    "prefix": ["ca", "dom.createAttribute"],
    "body": [
      "const ${1:attribute} = document.createAttribute('${2:name}');",
      "$1.value = ${3:'value'};",
      "node.setAttributeNode($1);"
    ],
    "description": "Creates a new attribute node.\n"
  },
  "Element.getAttributeNames()": {
    "prefix": ["dom.getAttributeNames"],
    "body": ["const ${2:attributeNames} = ${1:element}.getAttributeNames();"],
    "description": "Returns the attribute names of the element as an Array of strings. If the element has no attributes it returns an empty array.\n"
  },
  "Element.hasAttributes()": {
    "prefix": ["dom.hasAttributes"],
    "body": ["${1:element}.hasAttributes()"],
    "description": "returns a Boolean indicating whether the current element has any attributes or not.\n(DOM 2)\n"
  },
  "Element.setAttribute()": {
    "prefix": ["sa", "dom.setAttribute"],
    "body": ["${1:element}.setAttribute('${2:attrName}', '${3:value}');"],
    "description": "Sets the value of a named attribute of the current node.\n(Not namespace-aware, most commonly used methods)\n(DOM 1)\n"
  },
  "Element.getAttribute()": {
    "prefix": ["ga", "dom.getAttribute"],
    "body": ["const ${3:attribute} = ${1:element}.getAttribute('${2:attrName}');"],
    "description": "Retrieves the value of the named attribute from the current node and returns it as an Object.\n(Not namespace-aware, most commonly used methods)\n(DOM 1)\n"
  },
  "Element.hasAttribute()": {
    "prefix": ["ha", "dom.hasAttribute"],
    "body": ["${1:element}.hasAttribute('${2:attrName}')"],
    "description": "Returns a Boolean indicating if the element has the specified attribute or not.\n(Not namespace-aware, most commonly used methods)\n(DOM 2)\n"
  },
  "Element.removeAttribute()": {
    "prefix": ["ra", "dom.removeAttribute"],
    "body": ["${1:element}.removeAttribute('${2:attrName}');"],
    "description": "Removes the named attribute from the current node.\n(Not namespace-aware, most commonly used methods)\n(DOM 1)\n"
  },
  "Element.getAttributeNode()": {
    "prefix": ["gan", "dom.getAttributeNode"],
    "body": ["const ${3:attrNode} = ${1:element}.getAttributeNode('${2:attrName}');"],
    "description": "Returns the specified attribute of the specified element, as an Attr node.\n(DOM Level 1 methods for dealing with Attr nodes directly (seldom used))\n(DOM 1)"
  },
  "Element.setAttributeNode()": {
    "prefix": ["san", "dom.setAttributeNode"],
    "body": ["${1:element}.setAttributeNode(${2:attributeNode});"],
    "description": "Adds a new Attr node to the specified element.\n(DOM Level 1 methods for dealing with Attr nodes directly (seldom used))\n(DOM 1)"
  },
  "Element.removeAttributeNode()": {
    "prefix": ["ran", "dom.removeAttributeNode"],
    "body": ["${1:element}.removeAttributeNode(${2:attributeNode});"],
    "description": "Removes the specified attribute from the current element.\n(DOM Level 1 methods for dealing with Attr nodes directly (seldom used))\n(DOM 1)"
  },
  "Element.setAttributeNS()": {
    "prefix": ["sans", "dom.setAttributeNS"],
    "body": ["${1:element}.setAttributeNS('${2:namespace}', '${3:attrName}', '${4:value}');"],
    "description": "Adds a new attribute or changes the value of an attribute with the given namespace and name.\n(Namespace-aware variants (DOM Level 2))\n"
  },
  "Element.getAttributeNS()": {
    "prefix": ["ga", "dom.getAttributeNS"],
    "body": [
      "const ${4:attrVal} = ${1:element}.getAttributeNS('${2:namespace}', '${3:attrName}');"
    ],
    "description": "Returns the string value of the attribute with the specified namespace and name. If the named attribute does not exist, the value returned will either be null or \"\" (the empty string). \n(Namespace-aware variants (DOM Level 2))\n"
  },
  "Element.hasAttributeNS()": {
    "prefix": ["ha", "dom.hasAttributeNS"],
    "body": ["${1:element}.hasAttributeNS('${2:namespace}', '${3:attrName}')"],
    "description": "Returns a boolean value indicating whether the current element has the specified attribute.\n(Namespace-aware variants (DOM Level 2))\n"
  },
  "Element.removeAttributeNS()": {
    "prefix": ["ra", "dom.removeAttributeNS"],
    "body": ["${1:element}.removeAttributeNS('${2:namespace}', '${3:attrName}');"],
    "description": "Removes the specified attribute from an element.\n(Namespace-aware variants (DOM Level 2))\n"
  },
  "Element.setAttributeNodeNS()": {
    "prefix": "dom.setAttributeNodeNS",
    "body": ["${1:element}.setAttributeNodeNS(${2:attributeNode})"],
    "description": "Adds a new namespaced attribute node to an element.\n(DOM Level 2 namespace-aware methods for dealing with Attr nodes directly (seldom used))\n(DOM 2)\n"
  },
  "Element.getAttributeNodeNS()": {
    "prefix": "dom.getAttributeNodeNS",
    "body": [
      "const ${1:namespace} = '${2:<url/ns/specialspace>}';",
      "let ${3:attributeNode} = ${4:element}.getAttributeNodeNS(${1}, '${5:nodeName}')"
    ],
    "description": "Returns the Attr node for the attribute with the given namespace and name.\n(DOM Level 2 namespace-aware methods for dealing with Attr nodes directly (seldom used))\n(DOM 2)\n"
  },
  "Element.toggleAttribute()": {
    "prefix": ["ta", "dom.toggleAttribute"],
    "body": ["${1:element}.toggleAttribute('${2:attrName}');"],
    "description": "Toggles a boolean attribute, removing it if it is present and adding it if it is not present, on the specified element.\n"
  },
  "Node.insertBefore()": {
    "prefix": ["ib", "dom.insertBefore"],
    "body": ["${1:node}.insertBefore(${2:newNode}, ${3:referenceNode});"],
    "description": "The `Node.insertBefore()` method inserts a node before a reference node as a child of a specified parent node. \n"
  },
  "Node.appendChild()": {
    "prefix": ["ac", "dom.appendChild"],
    "body": ["${1:node}.appendChild(${2:element});"],
    "description": "The Node.appendChild() method adds a node to the end of the list of children of a specified parent node. If the given child is a reference to an existing node in the document, appendChild() moves it from its current position to the new position (there is no requirement to remove the node from its parent node before appending it to some other node).\n"
  },
  "ParentNode.append()": {
    "prefix": ["append", "dom.append"],
    "body": ["${1:parentNode}.append(${2:Nodes/DOMStrings});"],
    "description": "Inserts a set of Node objects or DOMString objects after the last child of the ParentNode. \n"
  },
  "ParentNode.prepend()": {
    "prefix": ["prepend", "dom.prepend"],
    "body": ["${1:parentNode}.prepend(${2:Nodes/DOMStrings});"],
    "description": "Inserts a set of Node objects or DOMString objects before the first child of the ParentNode. \n"
  },
  "ChildNode.after()": {
    "prefix": ["after", "dom.after"],
    "body": ["${1:childNode}.after(${2:Nodes/DOMStrings});"],
    "description": "Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent, just after this ChildNode. \n"
  },
  "ChildNode.before()": {
    "prefix": ["before", "dom.before"],
    "body": ["${1:childNode}.before(${2:Nodes/DOMStrings});"],
    "description": "Inserts a set of Node or DOMString objects in the children list of this ChildNode's parent,just before this ChildNode. \n"
  },
  "Element.insertAdjacentHTML('beforebegin', 'DOMString')": {
    "prefix": ["before", "dom.before.html"],
    "body": ["${1:element}.insertAdjacentHTML('beforebegin', ${2:'DOMString'});"],
    "description": "Before the element itself.\n"
  },
  "Element.insertAdjacentHTML('afterend', 'DOMString')": {
    "prefix": ["after", "dom.after.html"],
    "body": ["${1:element}.insertAdjacentHTML('afterend', ${2:'DOMString'});"],
    "description": "After the element itself.\n"
  },
  "Element.insertAdjacentHTML('afterbegin', 'DOMString')": {
    "prefix": ["prepend", "dom.prepend.html"],
    "body": ["${1:element}.insertAdjacentHTML('afterbegin', ${2:'DOMString'});"],
    "description": "Just inside the element, before its first child.\n"
  },
  "Element.insertAdjacentHTML('beforeend', 'DOMString')": {
    "prefix": ["append", "dom.append.html"],
    "body": ["${1:element}.insertAdjacentHTML('beforeend', ${2:'DOMString'});"],
    "description": "Just inside the element, after its last child.\n"
  },
  "Element.insertAdjacentElement('beforebegin', element)": {
    "prefix": ["before", "dom.before.element"],
    "body": ["${1:element}.insertAdjacentElement('beforebegin', ${2:element});"],
    "description": "Before the element itself.\n"
  },
  "Element.insertAdjacentElement('afterend', element)": {
    "prefix": ["after", "dom.after.element"],
    "body": ["${1:element}.insertAdjacentElement('afterend', ${2:element});"],
    "description": "After the element itself.\n"
  },
  "Element.insertAdjacentElement('afterbegin', element)": {
    "prefix": ["prepend", "dom.prepend.element"],
    "body": ["${1:element}.insertAdjacentElement('afterbegin', ${2:element});"],
    "description": "Just inside the element, before its first child.\n"
  },
  "Element.insertAdjacentElement('beforeend', element)": {
    "prefix": ["append", "dom.append.element"],
    "body": ["${1:element}.insertAdjacentElement('beforeend', ${2:element});"],
    "description": "Just inside the element, after its last child.\n"
  },
  "Element.insertAdjacentText('beforebegin', value)": {
    "prefix": ["before", "dom.before.text"],
    "body": ["${1:element}.insertAdjacentText('beforebegin', ${2:value});"],
    "description": "Before the element itself.\n"
  },
  "Element.insertAdjacentText('afterend', value)": {
    "prefix": ["after", "dom.after.text"],
    "body": ["${1:element}.insertAdjacentText('afterend', ${2:value});"],
    "description": "After the element itself.\n"
  },
  "Element.insertAdjacentText('afterbegin', value)": {
    "prefix": ["prepend", "dom.prepend.text"],
    "body": ["${1:element}.insertAdjacentText('afterbegin', ${2:value});"],
    "description": "Just inside the element, before its first child.\n"
  },
  "Element.insertAdjacentText('beforeend', value)": {
    "prefix": ["append", "dom.append.text"],
    "body": ["${1:element}.insertAdjacentText('beforeend', ${2:value});"],
    "description": "Just inside the element, after its last child.\n"
  },
  "Node.removeChild()": {
    "prefix": ["rmc", "dom.removeChild"],
    "body": ["${1:node}.removeChild(${2:child});"],
    "description": "removeChild\n"
  },
  "ChildNode.remove()": {
    "prefix": ["rm", "dom.remove"],
    "body": ["${1:childNode}.remove();"],
    "description": "Removes this ChildNode from the children list of its parent.\n"
  },
  "Node.replaceChild()": {
    "prefix": ["rpc", "dom.replaceChild"],
    "body": ["${1:parentNode}.replaceChild(${2:newChild}, ${3:oldChild});"],
    "description": "The `Node.replaceChild()` method replaces a child node within the given (parent) node.\n"
  },
  "ChildNode.replaceWith()": {
    "prefix": ["rpw", "dom.replaceWith"],
    "body": ["${1:childNode}.replaceWith(${2:Node/DOMString});"],
    "description": "The `ChildNode.replaceWith()` method replaces this ChildNode in the children list of its parent with a set of Node or DOMString objects. DOMString objects are inserted as equivalent Text nodes.\n"
  },
  "Node.getRootNode()": {
    "prefix": ["dom.getRootNode"],
    "body": ["const ${2:root} = ${1:node}.getRootNode(true);"],
    "description": "The getRootNode() method of the Node interface returns the context object's root, which optionally includes the shadow root if it is available.\n"
  },
  "ParentNode.firstElementChild": {
    "prefix": ["fec", "dom.firstElementChild"],
    "body": ["const ${2:element} = ${1:parentnode}.firstElementChild;"],
    "description": "The `Element.firstElementChild` read-only property returns an element's first child Element, or null if there are no child elements.\n"
  },
  "ParentNode.lastElementChild": {
    "prefix": ["lec", "dom.lastElementChild"],
    "body": ["const ${2:element} = ${1:parentnode}.lastElementChild;"],
    "description": "The `Element.lastElementChild` read-only property returns an element's last child Element, or null if there are no child elements.\n"
  },
  "ParentNode.children": {
    "prefix": ["children", "dom.children"],
    "body": ["const ${2:children} = ${1:parentnode}.children;"],
    "description": "The read-only children property returns a live HTMLCollection which contains all of the child elements of the element upon which it was called..\n"
  },
  "ParentNode.childElementCount": {
    "prefix": ["cec", "dom.childElementCount"],
    "body": ["const ${2:count} = ${1:parentnode}.childElementCount;"],
    "description": "Returns the number of children of this ParentNode which are elements.\n"
  },
  "Element.previousElementSibling": {
    "prefix": ["pes", "dom.previousElementSibling"],
    "body": ["const ${2:prevElement} = ${1:NonDocumentTypeChildNode}.previousElementSibling;"],
    "description": "The `Element.previousElementSibling` read-only property returns the Element immediately prior to the specified one in its parent's children list, or null if the specified element is the first one in the list.\n"
  },
  "Element.nextElementSibling": {
    "prefix": ["nes", "dom.nextElementSibling"],
    "body": ["const ${2:nextElement} = ${1:NonDocumentTypeChildNode}.nextElementSibling;"],
    "description": "The `Element.nextElementSibling` read-only property returns the element immediately following the specified one in its parent's children list, or null if the specified element is the last one in the list..\n"
  },
  "Element.closest()": {
    "prefix": ["closest", "dom.closest"],
    "body": ["const ${1:closestElement} = ${2:targetElement}.closest('${3:selectorString}');"],
    "description": "The `Element.closest()` method traverses the Element and its parents (heading toward the document root) until it finds a node that matches the provided selector string. Will return itself or the matching ancestor. If no such element exists, it returns null.\n"
  },
  "Node.childNodes": {
    "prefix": ["cn", "dom.childNodes"],
    "body": ["const ${2:nodeList} = ${1:node}.childNodes;"],
    "description": "Returns a live NodeList containing all the children of this node. \n"
  },
  "Node.parentElement": {
    "prefix": ["pe", "dom.parentElement"],
    "body": ["const ${2:parentElement} = ${1:node}.parentElement;"],
    "description": "Returns an Element that is the parent of this node. If the node has no parent, or if that parent is not an Element, this property returns null. \n"
  },
  "Node.parentNode": {
    "prefix": ["pn", "dom.parentNode"],
    "body": ["const ${2:parentNode} = ${1:node}.parentNode;"],
    "description": "Returns a Node that is the parent of this node. \n"
  },
  "Node.firstChild": {
    "prefix": ["fc", "dom.firstChild"],
    "body": ["const ${2:childNode} = ${1:node}.firstChild;"],
    "description": "Returns a Node representing the first direct child node of the node, or null if the node has no child.\n"
  },
  "Node.lastChild": {
    "prefix": ["lc", "dom.lastChild"],
    "body": ["const ${2:childNode} = ${1:node}.lastChild;"],
    "description": "Returns a Node representing the last direct child node of the node, or null if the node has no child.\n"
  },
  "Node.previousSibling": {
    "prefix": ["ps", "dom.previousSibling"],
    "body": ["const ${2:previousNode} = ${1:node}.previousSibling;"],
    "description": "Returns a Node representing the previous node in the tree, or null if there isn't such node.\n"
  },
  "Node.nextSibling": {
    "prefix": ["ns", "dom.nextSibling"],
    "body": ["const ${2:nextNode} = ${1:node}.nextSibling;"],
    "description": "Returns a Node representing the next node in the tree, or null if there isn't such node.\n"
  },
  "Document.getElementById": {
    "prefix": ["gi", "dom.getElementById"],
    "body": ["${1:document}.getElementById('${2:id}');"],
    "description": "Finding HTML elements by id.\n"
  },
  "Document.getElementsByClassName": {
    "prefix": ["gc", "dom.getElementsByClassName"],
    "body": ["${1:document}.getElementsByClassName('${2:className}');"],
    "description": "Finding HTML elements by class name.\n"
  },
  "Document.getElementsByTagName": {
    "prefix": ["gt", "dom.getElementsByTagName"],
    "body": ["${1:document}.getElementsByTagName('${2:tagName}');"],
    "description": "Finding HTML elements by tag name.\n"
  },
  "Document.querySelector": {
    "prefix": ["qs", "dom.querySelector"],
    "body": ["${1:document}.querySelector('${2:selector}');"],
    "description": "querySelector\n"
  },
  "Document.querySelectorAll": {
    "prefix": ["qsa", "dom.querySelectorAll"],
    "body": ["${1:document}.querySelectorAll('${2:selector}');"],
    "description": "querySelectorAll\n"
  },
  "Element.innerHTML": {
    "prefix": ["ih", "dom.innerHTML"],
    "body": [
      "${1:htmlElement}.innerHTML = ${2:'DOMString'};",
      "// const content = element.innerHTML;"
    ],
    "description": "The `innerHTML` property sets or returns the HTML content (inner HTML) of an element.\n"
  },
  "Element.outerHTML": {
    "prefix": ["oh", "dom.outerHTML"],
    "body": ["${1:element}.outerHTML = ${2:'DOMString'};", "// const content = element.outerHTML;"],
    "description": "The `outerHTML` property sets or returns the HTML element and all it's content, including the start tag, it's attributes, and the end tag.\n"
  },
  "HTMLElement.innerText": {
    "prefix": ["it", "dom.innerText"],
    "body": [
      "${1:htmlElement}.innerText = ${2:'renderText'};",
      "// const renderedText = htmlElement.innerText;"
    ],
    "description": "The `innerText` property sets or returns the text content of the specified node, and all its descendants.\n"
  },
  "Node.textContent": {
    "prefix": ["tc", "dom.textContent"],
    "body": ["${1:node}.textContent = '${2:content}';", "// const text = node.textContent;"],
    "description": "The `textContent` property of the Node interface represents the text content of the node and its descendants.\n"
  },
  "throw new Error()": {
    "prefix": ["tn", "throw.Error()"],
    "body": ["throw new Error(${1:'Something bad happened.'});"],
    "description": "throw new Error('message')\n"
  },
  "throw new EvalError()": {
    "prefix": ["tne", "throw.EvalError()"],
    "body": ["throw new EvalError(${1:\"The doesn't evaluate.\"});"],
    "description": "throw new EvalError('message')\n"
  },
  "throw new RangeError()": {
    "prefix": ["tnr", "throw.RangeError()"],
    "body": ["throw new RangeError(${1:\"Sorry, you just don't have the range.\"});"],
    "description": "throw new RangeError('message')\n"
  },
  "throw new ReferenceError()": {
    "prefix": ["tnre", "throw.ReferenceError()"],
    "body": ["throw new ReferenceError(${1:\"You didn't cite your references properly.\"});"],
    "description": "throw new ReferenceError('message')\n"
  },
  "throw new SyntaxError()": {
    "prefix": ["tns", "throw.SyntaxError()"],
    "body": ["throw new SyntaxError(${1:\"I don't like your syntax.\"});"],
    "description": "throw new SyntaxError('message')\n"
  },
  "throw new TypeError()": {
    "prefix": ["tnt", "throw.TypeError()"],
    "body": ["throw new TypeError(${1:'What type of variable do you take me for?'});"],
    "description": "throw new TypeError('message')\n"
  },
  "throw new URIError()": {
    "prefix": ["tnu", "throw.URIError()"],
    "body": ["throw new URIError(${1:'Uri, is that you?'});"],
    "description": "throw new URIError('message')\n"
  },
  "addEventListener()": {
    "prefix": ["ael", "dom.addEventListener()"],
    "body": ["${1:document}.addEventListener('${2:type}', ${3:listener});\n"],
    "description": "EventTarget.addEventListener()\n"
  },
  "removeEventListener()": {
    "prefix": ["rel", "dom.removeEventListener()"],
    "body": ["${1:document}.removeEventListener('${2:type}', ${3:listener});\n"],
    "description": "EventTarget.removeEventListener()\n"
  },
  "addEventListener arrow function": {
    "prefix": ["aela", "dom.addEventListener()"],
    "body": ["${1:document}.addEventListener('${2:type}', (${3:event}) => {\n\t${4}\n});\n"],
    "description": "addEventListener, arrow function\n"
  },
  "dispatchEvent()": {
    "prefix": ["dev", "dom.dispatchEvent()"],
    "body": ["const ${3:cancelled} = !${1:target}.dispatchEvent(${2:event});\n"],
    "description": "Dispatches an Event at the specified EventTarget\n"
  },
  "preventDefault() and stopPropagation()": {
    "prefix": ["eps"],
    "body": ["event.preventDefault();\nevent.stopPropagation();\nreturn false;"],
    "description": "event.preventDefault(); event.stopPropagation()\n"
  },
  "event preventDefault": {
    "prefix": ["epd"],
    "body": ["event.preventDefault();"],
    "description": "event preventDefault\n"
  },
  "event stopPropagation": {
    "prefix": ["esp"],
    "body": ["event.stopPropagation();"],
    "description": "event stopPropagation\n"
  },
  "click": {
    "prefix": "click",
    "body": ["document.addEventListener('click', () => {", "\t${1}", "});", ""],
    "description": "click"
  },
  "keydown": {
    "prefix": "keydown",
    "body": [
      "document.addEventListener('keydown', event => {",
      "\tif (event.ctrlKey && event.which === 72) {",
      "\t\t${1}",
      "\t}",
      "});",
      ""
    ],
    "description": "keydown \n"
  },
  "load": {
    "prefix": "load",
    "body": ["window.addEventListener('load', () => {", "\t${1}", "});", ""],
    "description": "page is fully loaded \n should be used only to detect a fully-loaded page. \n"
  },
  "ready": {
    "prefix": "ready",
    "body": ["window.addEventListener('DOMContentLoaded', () => {", "\t${1}", "});", ""],
    "description": "DOM fully loaded and parsed. \n The DOMContentLoaded event fires when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading. \n"
  },
  "CustomEvent()": {
    "prefix": "CustomEvent",
    "body": [
      "const ${1:event} = new CustomEvent('${2:type}', {",
      "\tbubbles: false,",
      "\tcancelable: false,",
      "\tcomposed: false,",
      "\tdetail: null",
      "});",
      "${3:elem}.addEventListener('$2', (event) => {",
      "\t$0",
      "});",
      "$3.dispatchEvent($1);"
    ],
    "description": "Creating and triggering events"
  },
  "Event()": {
    "prefix": "Event",
    "body": [
      "const ${1:event} = new Event('${2:type}');",
      "${3:elem}.addEventListener('$2', (event) => {",
      "\t$0",
      "});",
      "$3.dispatchEvent($1);"
    ],
    "description": "Creating and triggering events"
  },
  "function named": {
    "prefix": "fn",
    "body": ["function ${1:name}(${2:param}) {\n\t${3}\n}\n"],
    "description": "function named\n"
  },
  "function anonymous": {
    "prefix": "fna",
    "body": ["function(${1:param}) {\n\t${2}\n}"],
    "description": "function anonymous\n"
  },
  "function statements(var)": {
    "prefix": "vfn",
    "body": ["var ${1:name} = function (${2:param}) {\n\t${3}\n}\n"],
    "description": "function statements(var)\n"
  },
  "function statements(let)": {
    "prefix": "lfn",
    "body": ["let ${1:name} = function (${2:param}) {\n\t${3}\n}\n"],
    "description": "function statements(let)\n"
  },
  "function statements(const)": {
    "prefix": "cfn",
    "body": ["const ${1:name} = function (${2:param}) {\n\t${3}\n}\n"],
    "description": "function statements(const)\n"
  },
  "arrow function statements(let)": {
    "prefix": ["laf"],
    "body": ["let ${1:name} = (${2:param}) => {\n\t${3}\n}\n"],
    "description": "arrow function statements(let)\n"
  },
  "arrow function expression(let)": {
    "prefix": "lafe",
    "body": ["let ${1:name} = (${2:param}) => ${3};\n"],
    "description": "arrow function expression(let)\n"
  },
  "arrow function statements(const)": {
    "prefix": ["caf"],
    "body": ["const ${1:name} = (${2:param}) => {\n\t${3}\n}\n"],
    "description": "arrow function statements(const)\n"
  },
  "arrow function expression(const)": {
    "prefix": "cafe",
    "body": ["const ${1:name} = (${2:param}) => ${3};\n"],
    "description": "arrow function expression(const)\n"
  },
  "function property": {
    "prefix": "pfn",
    "body": ["${1:name}: function(${2:param}) {\n\t${3}\n}"],
    "description": "function as a property of an object\n"
  },
  "function apply": {
    "prefix": "fnapply",
    "body": ["${1:method}.apply(${2:context}, [${3:param}]);"],
    "description": "function.apply(thisArg, [argsArray])\n"
  },
  "function call": {
    "prefix": "fncall",
    "body": ["${1:method}.call(${2:context}, ${3:param});"],
    "description": "function.call(thisArg, arg1, arg2, ...)\n"
  },
  "function bind": {
    "prefix": "fnbind",
    "body": ["${1:method}.bind(${2:this});"],
    "description": "function.bind(thisArg[, arg1[, arg2[, ...]]])\n"
  },
  "arrow function statements": {
    "prefix": ["af", "afs"],
    "body": ["(${1:param}) => {\n\t${2}\n}\n"],
    "description": "arrow function statements\n"
  },
  "arrow function expression": {
    "prefix": "afe",
    "body": ["(${1:param}) => ${2}"],
    "description": "arrow function expression\n"
  },
  "arrow function with return": {
    "prefix": "afr",
    "body": ["(${1:param}) => {\n\treturn ${2};\n}\n"],
    "description": "arrow function with return\n"
  },
  "arrow function with destructuring": {
    "prefix": "afd",
    "body": ["({${1:param}}) => ${2:statement}\n"],
    "description": "arrow function with destructuring\n"
  },
  "iife, arrow function": {
    "prefix": "iif",
    "body": [";((${1:param}) => {\n\t${3}\n})(${2})\n"],
    "description": "immediately-invoked function expression (IIFE)\n"
  },
  "iife": {
    "prefix": "iife",
    "body": [";(function (${1:param}) {\n\t${3}\n})(${2})\n"],
    "description": "immediately-invoked function expression (IIFE)\n"
  },
  "new.target": {
    "prefix": "nt",
    "body": [
      "if (typeof new.target === 'undefined') {\n\tthrow new Error('Fn() must be called with new');\n}"
    ]
  },
  "const yielded": {
    "prefix": "cy",
    "body": ["const ${1:name} = yield ${2:value};"],
    "description": "const assignment yielded\n"
  },
  "let yielded": {
    "prefix": "ly",
    "body": ["let ${1:name} = yield ${2:value};"],
    "description": "let assignment yielded\n"
  },
  "generator function": {
    "prefix": "gf",
    "body": [
      "function* ${1:name}(${2:param}) {",
      "\tyield* ${3:expression}();",
      "\tyield ${4:expression};",
      "}"
    ],
    "description": "Creates generator function\n"
  },
  "generator method": {
    "prefix": "gm",
    "body": [
      "*generator(${1:param}) {",
      "\tyield* ${3:expression}();",
      "\tyield ${4:expression};",
      "},"
    ],
    "description": "generator method"
  },
  "async generator method": {
    "prefix": "asgm",
    "body": [
      "async *generator(${1:param}) {",
      "\tyield* ${3:expression}();",
      "\tyield ${4:expression};",
      "},"
    ],
    "description": "async generator method"
  },
  "generator method expression": {
    "prefix": "gme",
    "body": [
      "*[generator](${1:param}) {",
      "\tyield* ${3:expression}();",
      "\tyield ${4:expression};",
      "},"
    ],
    "description": "generator method with computed keys"
  },
  "async generator method expression": {
    "prefix": "asgme",
    "body": [
      "async *[generator](${1:param}) {",
      "\tyield* ${3:expression}();",
      "\tyield ${4:expression};",
      "},"
    ],
    "description": "async generator method with computed keys"
  },
  "yield": {
    "prefix": "y",
    "body": ["yield ${1:expression};"],
    "description": "The yield keyword is used to pause and resume a generator function (function* or legacy generator function).\n"
  },
  "yield*": {
    "prefix": "yg",
    "body": ["yield* ${1:expression}();"],
    "description": "The yield* expression is used to delegate to another generator or iterable object."
  },
  "eslint-disable": {
    "prefix": "ed",
    "body": ["/* eslint-disable ${1:no-console, no-unused-vars} */"],
    "description": "Disabling Rules with Inline Comments"
  },
  "eslint-enable": {
    "prefix": "ee",
    "body": ["/* eslint-enable ${1:no-console, no-unused-vars} */"],
    "description": "Disabling Rules with Inline Comments"
  },
  "eslint-disable-line": {
    "prefix": "edl",
    "body": ["// eslint-disable-line ${1:no-console, no-unused-vars}"],
    "description": "Disabling Rules with Inline Comments"
  },
  "eslint-disable-next-line": {
    "prefix": "ednl",
    "body": ["// eslint-disable-next-line ${1:no-console, no-unused-vars}"],
    "description": "Disabling Rules with Inline Comments"
  },
  "let Map": {
    "prefix": "lm",
    "body": ["let ${1:resource}Map = new Map();"],
    "description": "let assignment Map\n"
  },
  "let Set": {
    "prefix": "ls",
    "body": ["let ${1:resource}Set = new Set();"],
    "description": "let assignment Set\n"
  },
  "let WeakMap": {
    "prefix": "lwm",
    "body": ["let ${1:resource}WeakMap = new WeakMap();"],
    "description": "let assignment WeakMap\n"
  },
  "let WeakSet": {
    "prefix": "lws",
    "body": ["let ${1:resource}WeakSet = new WeakSet();"],
    "description": "let assignment WeakSet\n"
  },
  "const Map": {
    "prefix": ["cm", "map"],
    "body": ["const ${1:resource}Map = new Map();"],
    "description": "const assignment Map\n"
  },
  "const Set": {
    "prefix": ["cs", "set"],
    "body": ["const ${1:resource}Set = new Set();"],
    "description": "const assignment Set\n"
  },
  "const WeakMap": {
    "prefix": ["cwm", "wm"],
    "body": ["const ${1:resource}WeakMap = new WeakMap();"],
    "description": "const assignment WeakMap\n"
  },
  "const WeakSet": {
    "prefix": ["cws", "ws"],
    "body": ["const ${1:resource}WeakSet = new WeakSet();"],
    "description": "const assignment WeakSet\n"
  },
  "Map.prototype.size": {
    "prefix": "map.size",
    "body": ["${1:map}.size"],
    "description": "The size accessor property returns the number of elements in a Map object.\n"
  },
  "Map.prototype.clear()": {
    "prefix": "map.clear()",
    "body": ["${1:map}.clear();"],
    "description": "The clear() method removes all elements from a Map object.\n"
  },
  "Map.prototype.delete()": {
    "prefix": "map.delete()",
    "body": ["${1:map}.delete(${2:key});"],
    "description": "The delete() method removes the specified element from a Map object by key.\n"
  },
  "Map.prototype.forEach()": {
    "prefix": "map.forEach()",
    "body": ["${1:map}.forEach((${2:value}, ${3:key}) => {", "\t$0", "});"],
    "description": "The forEach() method executes a provided function once per each key/value pair in the Map object, in insertion order.\n"
  },
  "Map.prototype.get()": {
    "prefix": "map.get()",
    "body": ["${1:map}.get(${2:key});"],
    "description": "The get() method returns a specified element from a Map object. If the value that is associated to the provided key is an object, then you will get a reference to that object and any change made to that object will effectively modify it inside the Map object.\n"
  },
  "Map.prototype.has()": {
    "prefix": "map.has()",
    "body": ["${1:map}.has(${2:key})"],
    "description": "The has() method returns a boolean indicating whether an element with the specified key exists or not.\n"
  },
  "Map.prototype.set()": {
    "prefix": "map.set()",
    "body": ["${1:map}.set(${2:key}, ${3:value})"],
    "description": "The set() method adds or updates an element with a specified key and a value to a Map object.\n"
  },
  "Map.prototype.entries()": {
    "prefix": "map.entries()",
    "body": ["const ${2:iterator} = ${1:map}.entries();", "$2.next().value"],
    "description": "The entries() method returns a new Iterator object that contains the [key, value] pairs for each element in the Map object in insertion order.\n"
  },
  "Map.prototype.keys()": {
    "prefix": "map.keys()",
    "body": ["const ${2:iterator} = ${1:map}.keys();", "$2.next().value"],
    "description": "The keys() method returns a new Iterator object that contains the keys for each element in the Map object in insertion order.\n"
  },
  "Map.prototype.values()": {
    "prefix": "map.values()",
    "body": ["const ${2:iterator} = ${1:map}.values()", "$2.next().value"],
    "description": "The values() method returns a new Iterator object that contains the values for each element in the Map object in insertion order.\n"
  },
  "Map.prototype[@@iterator]()": {
    "prefix": "map.@@iterator()",
    "body": ["const ${2:iterator} = ${1:map}[Symbol.iterator]();", "$2.next().value"],
    "description": "The initial value of the @@iterator property is the same function object as the initial value of the entries method.\n"
  },
  "get Map[@@species]": {
    "prefix": ["map.@@species"],
    "body": ["class FeatureMap extends Map {", "\tstatic get [@@species]() { return Map; }", "}"],
    "description": "The Map[@@species] accessor property returns the Map constructor.\n"
  },
  "WeakMap.prototype.delete()": {
    "prefix": "weakmap.delete()",
    "body": ["${1:weakmap}.delete(${2:key})"],
    "description": "The delete() method removes the specified element from a WeakMap object.\n"
  },
  "WeakMap.prototype.get()": {
    "prefix": "weakmap.get()",
    "body": ["${1:weakmap}.get(${2:key})"],
    "description": "The get() method returns a specified element from a WeakMap object.\n"
  },
  "WeakMap.prototype.has()": {
    "prefix": "weakmap.has()",
    "body": ["${1:weakmap}.has(${2:key})"],
    "description": "The has() method returns a boolean indicating whether an element with the specified key exists in the WeakMap object or not.\n"
  },
  "WeakMap.prototype.set()": {
    "prefix": "weakmap.set()",
    "body": ["${1:weakmap}.set(${2:key}, ${3:value})"],
    "description": "The set() method adds a new element with a specified key and value to a WeakMap object.\n"
  },
  "Set.prototype.size": {
    "prefix": "set.size",
    "body": ["${1:set}.size"],
    "description": "The size accessor property returns the number of (unique) elements in a Set object.\n"
  },
  "Set.prototype.add()": {
    "prefix": "set.add()",
    "body": ["${1:set}.add(${2:value})"],
    "description": "The add() method appends a new element with a specified value to the end of a Set object.\n"
  },
  "Set.prototype.clear()": {
    "prefix": "set.clear()",
    "body": ["${1:set}.clear()"],
    "description": "The clear() method removes all elements from a Set object.\n"
  },
  "Set.prototype.delete()": {
    "prefix": "set.delete()",
    "body": ["${1:set}.delete(${2:value})"],
    "description": "The delete() method removes a specified value from a Set object, if it is in the set.\n"
  },
  "Set.prototype.forEach()": {
    "prefix": "set.forEach()",
    "body": ["${1:set}.forEach((${2:value}) => {", "\t$0", "});"],
    "description": "The forEach() method executes a provided function once for each value in the Set object, in insertion order.\n"
  },
  "Set.prototype.has()": {
    "prefix": "set.has()",
    "body": ["${1:set}.has(${2:value})"],
    "description": "The has() method returns a boolean indicating whether an element with the specified value exists in a Set object or not.\n"
  },
  "Set.prototype.entries()": {
    "prefix": "set.entries()",
    "body": ["const ${2:iterator} = ${1:set}.entries();", "$2.next().value"],
    "description": "The entries() method returns a new Iterator object that contains an array of [value, value] for each element in the Set object, in insertion order. For Set objects there is no key like in Map objects. However, to keep the API similar to the Map object, each entry has the same value for its key and value here, so that an array [value, value] is returned.\n"
  },
  "Set.prototype.values()": {
    "prefix": "set.values()",
    "body": ["const ${2:iterator} = ${1:set}.values()", "$2.next().value"],
    "description": "The values() method returns a new iterator object that contains the values for each element in the Set object in insertion order.\n"
  },
  "Set.prototype[@@iterator]()": {
    "prefix": "set.@@iterator()",
    "body": ["const ${2:iterator} = ${1:set}[Symbol.iterator]();", "$2.next().value"],
    "description": "The initial value of the @@iterator property is the same function object as the initial value of the values property.\n"
  },
  "get Set[@@species]": {
    "prefix": ["set.@@species"],
    "body": ["class FeatureSet extends Set {", "\tstatic get [@@species]() { return Set; }", "}"],
    "description": "The Set[Symbol.species] accessor property returns the Set constructor.\n"
  },
  "WeakSet.prototype.add()": {
    "prefix": "weakset.add()",
    "body": ["${1:weakset}.add(${2:value})"],
    "description": "The add() method appends a new object to the end of a WeakSet object.\n"
  },
  "WeakSet.prototype.delete()": {
    "prefix": "weakset.delete()",
    "body": ["${1:weakset}.delete(${2:value})"],
    "description": "The delete() method removes the specified element from a WeakSet object.\n"
  },
  "WeakSet.prototype.has()": {
    "prefix": "weakset.has()",
    "body": ["${1:weakset}.has(${2:value})"],
    "description": "The has() method returns a boolean indicating whether an object exists in a WeakSet or not.\n"
  },
  "Math.random": {
    "prefix": "mr",
    "body": ["Math.random()"],
    "description": "The Math.random() function returns a floating-point, pseudo-random number in the range 0–1 (inclusive of 0, but not 1) with approximately uniform distribution over that range."
  },
  "Math.round": {
    "prefix": "mro",
    "body": ["Math.round()"],
    "description": "The Math.round() function returns the value of a number rounded to the nearest integer."
  },
  "Math.floor": {
    "prefix": "mf",
    "body": ["Math.floor()"],
    "description": "The Math.floor() function returns the largest integer less than or equal to a given number."
  },
  "Math.ceil": {
    "prefix": "mc",
    "body": ["Math.ceil()"],
    "description": "The Math.ceil() function always rounds a number up to the next largest whole number or integer."
  },
  "Math.trunc": {
    "prefix": "mtr",
    "body": ["Math.trunc()"],
    "description": "The Math.trunc() function returns the integer part of a number by removing any fractional digits."
  },
  "import individual features": {
    "prefix": "im",
    "body": ["import { ${2:moduleName} } from '${1:module}';"],
    "description": "Import individual features\n"
  },
  "import default export": {
    "prefix": "imd",
    "body": ["import ${2:moduleName} from '${1:module}';"],
    "description": "Import default export\n"
  },
  "import renamed exports": {
    "prefix": "imas",
    "body": ["import { ${2:originalName} as ${3:alias} } from '${1:module}';"],
    "description": "Import renamed exports\n"
  },
  "import all module as alias": {
    "prefix": "imall",
    "body": ["import * as ${2:alias} from '${1:module}';"],
    "description": "Import all of a module's exports as a module object\n"
  },
  "import without module name": {
    "prefix": "imn",
    "body": ["import '${1:module}';"],
    "description": "Import a module for side effects only\n"
  },
  "export": {
    "prefix": "ex",
    "body": ["export { ${1:feature} };"],
    "description": "*export list\n"
  },
  "export renaming": {
    "prefix": "exas",
    "body": ["export { ${1:variable} as ${2:feature} };"],
    "description": "*renaming exports as\n"
  },
  "export const": {
    "prefix": "exc",
    "body": ["export const ${1:name} = ${2:value};"],
    "description": "exporting individual features(const)\n"
  },
  "export arrow function statements": {
    "prefix": "exaf",
    "body": ["export const ${1:name} = (${2:param}) => {", "\t$3", "};"],
    "description": "export named arrow function statements\n"
  },
  "export arrow function expression": {
    "prefix": "exafe",
    "body": ["export const ${1:name} = (${2:param}) => $3;"],
    "description": "export named arrow function expression\n"
  },
  "export async arrow function (named)": {
    "prefix": "exasafn",
    "body": [
      "export const ${1:name} = async (${2:param}) => {",
      "\tconst ${3:result} = await ${4:promise};",
      "\treturn ${3:result};",
      "};",
      ""
    ],
    "description": "export named async arrow function\n"
  },
  "export default arrow function statements": {
    "prefix": "exdaf",
    "body": ["export default (${1:param}) => {", "\t${2}", "}", ""],
    "description": "export default arrow function statements\n"
  },
  "export default arrow function expression": {
    "prefix": "exdafe",
    "body": ["export default (${1:param}) => ${2}", ""],
    "description": "export default arrow function expression\n"
  },
  "export default async arrow function": {
    "prefix": "exdasaf",
    "body": ["export default async (${1:param}) => {", "\t${2}", "}", ""],
    "description": "export default async arrow function\n"
  },
  "export function (named)": {
    "prefix": "exfn",
    "body": ["export function ${1:name}(${2:param}) {", "\t${3}", "}"],
    "description": "export named function\n"
  },
  "export async function (named)": {
    "prefix": "exasfn",
    "body": [
      "export async function ${1:name}(${2:param}) {\n\tconst ${3:result} = await ${4:promise};\n\treturn ${3:result};\n}\n"
    ],
    "description": "export named async function\n"
  },
  "export default function": {
    "prefix": "exdfn",
    "body": ["export default function (${1:param}) {", "\t${2}", "}", ""],
    "description": "export default function\n"
  },
  "export default async function": {
    "prefix": "exdasfn",
    "body": ["export default async function (${1:param}) {", "\t${2}", "}", ""],
    "description": "export default async function\n"
  },
  "export default": {
    "prefix": "exd",
    "body": ["export default ${1:expression};"],
    "description": "*export default\n"
  },
  "export as default": {
    "prefix": "exdas",
    "body": ["export { ${1:name} as default };"],
    "description": "export as default\n"
  },
  "export class": {
    "prefix": "exdc",
    "body": [
      "export default class ${1:className} {",
      "\tconstructor (${2:param}) {",
      "\t\t${3}",
      "\t}",
      "}",
      ""
    ],
    "description": "export class\n"
  },
  "export class extends": {
    "prefix": "exdce",
    "body": [
      "export default class ${1:className} extends ${2:baseClassName} {",
      "\tconstructor (${3:param}) {",
      "\t\tsuper();",
      "\t\t${4}",
      "\t}",
      "}"
    ],
    "description": "export class extends\n"
  },
  "export from": {
    "prefix": "exfr",
    "body": ["export {${1:default}} from ${2:otherModule};"],
    "description": "*aggregating modules, export from\n"
  },
  "export all from other module": {
    "prefix": "exallo",
    "body": ["export * from ${1:otherModule};"],
    "description": "export all from other module\n"
  },
  "Number.EPSILON": {
    "prefix": ["ne", "Num.EPSILON"],
    "body": ["Number.EPSILON"],
    "description": "Number.EPSILON = Math.pow(2, -52);\n"
  },
  "Number.MAX_SAFE_INTEGER": {
    "prefix": ["nmasi", "Num.MAX_SAFE_INTEGER"],
    "body": ["Number.MAX_SAFE_INTEGER"],
    "description": "Number.MAX_SAFE_INTEGER = 9007199254740991; // Math.pow(2, 53) - 1;\n"
  },
  "Number.MAX_VALUE": {
    "prefix": ["nmav", "Num.MAX_VALUE"],
    "body": ["Number.MAX_VALUE"],
    "description": "The MAX_VALUE property has a value of approximately 1.79E+308, or 21024. Values larger than MAX_VALUE are represented as Infinity.\n"
  },
  "Number.MIN_SAFE_INTEGER": {
    "prefix": ["nmisi", "Num.MIN_SAFE_INTEGER"],
    "body": ["Number.MIN_SAFE_INTEGER"],
    "description": "Number.MIN_SAFE_INTEGER = -9007199254740991; // -(Math.pow(2, 53) - 1)\n"
  },
  "Number.MIN_VALUE": {
    "prefix": ["nmav", "Num.MIN_VALUE"],
    "body": ["Number.MIN_VALUE"],
    "description": "The MIN_VALUE property is the number closest to 0, not the most negative number, that JavaScript can represent.\nMIN_VALUE has a value of approximately 5e-324. Values smaller than MIN_VALUE ('underflow values') are converted to 0.\n"
  },
  "Number.NEGATIVE_INFINITY": {
    "prefix": ["nni", "Num.NEGATIVE_INFINITY"],
    "body": ["Number.NEGATIVE_INFINITY"],
    "description": "represents the negative Infinity value.\n"
  },
  "Number.NaN": {
    "prefix": ["nn", "Num.NaN"],
    "body": ["Number.NaN"],
    "description": "represents Not-A-Number. Equivalent of **NaN**.\n"
  },
  "Number.POSITIVE_INFINITY": {
    "prefix": ["npi", "Num.POSITIVE_INFINITY"],
    "body": ["Number.POSITIVE_INFINITY"],
    "description": "represents the positive Infinity value.\n"
  },
  "Number.isFinite()": {
    "prefix": ["nif", "Num.isFinite()"],
    "body": ["Number.isFinite(${1:value})"],
    "description": "return a Boolean indicating whether or not the given value is a finite number.\n"
  },
  "Number.isInteger()": {
    "prefix": ["nii", "Num.isInteger()"],
    "body": ["Number.isInteger(${1:value})"],
    "description": "return a Boolean indicating whether or not the given value is an integer.\n"
  },
  "Number.isNaN()": {
    "prefix": ["nin", "Num.isNaN()"],
    "body": ["Number.isNaN(${1:value})"],
    "description": "return **true** if the given value is NaN and its type is Number; otherwise, **false**.\n"
  },
  "Number.isSafeInteger()": {
    "prefix": ["nisi", "Num.isSafeInteger()"],
    "body": ["Number.isSafeInteger(${1:value})"],
    "description": "return a Boolean indicating whether or not the given value is a number that is a safe integer.\n"
  },
  "Number.parseFloat()": {
    "prefix": ["npf", "Num.parseFloat()"],
    "body": ["Number.parseFloat(${1:string})"],
    "description": "parses a string argument and returns a floating point number.\n"
  },
  "Number.parseInt()": {
    "prefix": ["npi", "Num.parseInt()"],
    "body": ["Number.parseInt(${1:string})"],
    "description": "Number.parseInt(string,[ radix])\nparses a string argument and returns an integer of the specified radix or base.\n"
  },
  "Number.prototype.toExponential()": {
    "prefix": ["nte", "num.toExponential()"],
    "body": ["number.toExponential()"],
    "description": "numObj.toExponential([fractionDigits])\nreturn a string representing the Number object in exponential notation.\n"
  },
  "Number.prototype.toFixed()": {
    "prefix": ["ntf", "num.toFixed()"],
    "body": ["number.toFixed()"],
    "description": "numObj.toFixed([digits])\nformats a number using fixed-point notation.\n"
  },
  "Number.prototype.toPrecision()": {
    "prefix": ["ntp", "num.toPrecision()"],
    "body": ["number.toPrecision()"],
    "description": "numObj.toPrecision([precision])\nreturn a string representing the Number object to the specified precision."
  },
  "object literal": {
    "prefix": "ol",
    "body": ["{", "\t${1:key}: ${2:value},$0", "}"],
    "description": "object literal\n"
  },
  "key/value pair": {
    "prefix": "kv",
    "body": ["${1:key}: ${2:value},"],
    "description": "key/value pair\n"
  },
  "object method()": {
    "prefix": "om",
    "body": ["${1:method}(${2:param}) {", "\t${3}", "},"],
    "description": "method\n"
  },
  "object set": {
    "prefix": "oset",
    "body": ["set ${1:property}(${2:value}) {\n\t$3\n},"],
    "description": "setter"
  },
  "object get": {
    "prefix": "oget",
    "body": ["get ${1:property}() {\n\t$2\n},"],
    "description": "getter"
  },
  "object set with computed keys": {
    "prefix": "osete",
    "body": ["set [${1:property}](${2:value}) {\n\t$3\n},"],
    "description": "setter"
  },
  "object get with computed keys": {
    "prefix": "ogete",
    "body": ["get [${1:property}]() {\n\t$2\n},"],
    "description": "getter"
  },
  "object arrow method statements": {
    "prefix": "oam",
    "body": ["${1:method}: (${2:param}) => {", "\t${3}", "},"],
    "description": "note we can't use an arrow function if we want to use `this`.\n"
  },
  "object arrow method expression": {
    "prefix": "oame",
    "body": ["${1:method}: (${2:param}) => ${3},"],
    "description": "note we can't use an arrow function if we want to use `this`.\n"
  },
  "object async method()": {
    "prefix": "oasm",
    "body": ["async ${1:method}(${2:param}) {", "\t${3}", "},"],
    "description": "async method\n"
  },
  "Object.assign()": {
    "prefix": ["oa", "Obj.assign()"],
    "body": ["Object.assign(${1:target}, ${2:source});"],
    "description": "Object.assign(target, ...sources);\nreturn the target object.\n"
  },
  "Object.create()": {
    "prefix": ["oc", "Obj.create()"],
    "body": ["Object.create(${1:obj});"],
    "description": "Object.create(proto, [propertiesObject]);\nreturn a new object with the specified prototype object and properties.\nA TypeError exception if the propertiesObject parameter is 'null' or a non-primitive-wrapper object.\n"
  },
  "Object.defineProperty(data descriptors)": {
    "prefix": ["odp", "Obj.defineProperty()"],
    "body": [
      "Object.defineProperty(${1:dest}, '${2:propertyName}', {",
      "\t${3:value}: ${4:undefined},",
      "\t${5:configurable}: ${6:false},",
      "\t${7:enumerable}: ${8:false},",
      "\t${9:writable}: ${10:false}",
      "})"
    ],
    "description": "Object.defineProperty(data descriptors)\ndata descriptors\ndefines new or modifies existing properties directly on an object, \nreturning the object.\n"
  },
  "Object.defineProperty(accessor descriptors)": {
    "prefix": ["odpa", "Obj.defineProperty()"],
    "body": [
      "Object.defineProperty(${1:dest}, '${2:propertyName}', {",
      "\tget() {",
      "\t\treturn ${3:value};",
      "\t},",
      "\tset(${4:newValue}) {",
      "\t\t${5:value} = ${4:newValue};",
      "\t},",
      "\tenumerable: ${6:false},",
      "\tconfigurable: ${7:false}",
      "})"
    ],
    "description": "Object.defineProperty(accessor descriptors)\naccessor descriptors\ndefines new or modifies existing properties directly on an object, \nreturning the object.\n"
  },
  "Object.defineProperties()": {
    "prefix": ["odps", "Obj.defineProperties()"],
    "body": [
      "Object.defineProperties(${1:dest}, {",
      "\t${2:propertyName}: {",
      "\t\tconfigurable: ${3:false},",
      "\t\tenumerable: ${4:false},",
      "\t\tvalue: ${5:undefined},",
      "\t\twritable: ${6:false}",
      "\t},",
      "\t${7:propertyName}: {",
      "\t\tget() {",
      "\t\t\treturn ${8:value};",
      "\t\t},",
      "\t\tset(${9:newValue}) {",
      "\t\t\t${10:value} = ${9:newValue};",
      "\t\t},",
      "\t\tenumerable: ${11:false},",
      "\t\tconfigurable: ${12:false}",
      "\t}",
      "});"
    ],
    "description": "Object.defineProperties(obj, props)\ndefines new or modifies existing properties directly on an object, \nreturning the object.\n"
  },
  "Object.freeze()": {
    "prefix": ["of", "Obj.freeze()"],
    "body": ["Object.freeze(${1:obj});"],
    "description": "Object.freeze(obj);\nreturn the same object that was passed in.\n"
  },
  "Object.fromEntries()": {
    "prefix": ["ofe", "Obj.fromEntries()"],
    "body": ["Object.fromEntries(${1:iterable});"],
    "description": "Object.fromEntries(iterable);\ntransforms a list of key-value pairs into an object.\n"
  },
  "Object.getOwnPropertyDescriptor()": {
    "prefix": ["ogopd", "Obj.getOwnPropertyDescriptor()"],
    "body": ["Object.getOwnPropertyDescriptor(${1:obj}, '${2:propertyName}');"],
    "description": "Object.getOwnPropertyDescriptor(obj, propertyName);\nreturn a property descriptor of the given property if it exists on the object, 'undefined' otherwise.\n"
  },
  "Object.getOwnPropertyDescriptors()": {
    "prefix": ["ogopds", "Obj.getOwnPropertyDescriptors()"],
    "body": ["Object.getOwnPropertyDescriptors(${1:obj});"],
    "description": "Object.getOwnPropertyDescriptors(obj);\nreturn an object containing all own property descriptors of an object. Might be an empty object, if there are no properties.\n"
  },
  "Object.getOwnPropertyNames()": {
    "prefix": ["ogopn", "Obj.getOwnPropertyNames()"],
    "body": ["Object.getOwnPropertyNames(${1:obj});"],
    "description": "Object.getOwnPropertyNames(obj);\nreturn an array of all properties (including non-enumerable properties except for those which use Symbol) found directly in a given object.\n"
  },
  "Object.getOwnPropertySymbols()": {
    "prefix": ["ogops", "Obj.getOwnPropertySymbols()"],
    "body": ["Object.getOwnPropertySymbols(${1:obj});"],
    "description": "Object.getOwnPropertySymbols(obj);\nreturn an array of all symbol properties found directly upon a given object.\n"
  },
  "Object.getPrototypeOf()": {
    "prefix": ["ogpo", "Obj.getPrototypeOf()"],
    "body": ["Object.getPrototypeOf(${1:obj});"],
    "description": "Object.getPrototypeOf(obj);\nreturn the prototype of the given object. If there are no inherited properties, 'null' is returned.\n"
  },
  "Object.is()": {
    "prefix": ["oi", "Obj.is()"],
    "body": ["Object.is(${1:value1}, ${2:value2});"],
    "description": "Object.is(value1, value2);\ndetermines whether two values are the same value\n"
  },
  "Object.isExtensible()": {
    "prefix": ["oie", "Obj.isExtensible()"],
    "body": ["Object.isExtensible(${1:obj})"],
    "description": "Object.isExtensible(obj);\ndetermines if an object is extensible (whether it can have new properties added to it).\n"
  },
  "Object.isFrozen()": {
    "prefix": ["oif", "Obj.isFrozen()"],
    "body": ["Object.isFrozen(${1:obj})"],
    "description": "Object.isFrozen(obj);\ndetermines if an object is frozen.\n"
  },
  "Object.isSealed()": {
    "prefix": ["ois", "Obj.isSealed()"],
    "body": ["Object.isSealed(${1:obj})"],
    "description": "Object.isSealed(obj);\ndetermines if an object is sealed.\n"
  },
  "Object.preventExtensions()": {
    "prefix": ["ope", "Obj.preventExtensions()"],
    "body": ["Object.preventExtensions(${1:obj});"],
    "description": "Object.preventExtensions(obj);\nreturn the object being made non-extensible.\n"
  },
  "Object.seal()": {
    "prefix": ["os", "Obj.seal()"],
    "body": ["Object.seal(${1:obj});"],
    "description": "Object.seal(obj);\nseals an object, preventing new properties from being added to it and marking all existing properties as non-configurable. Values of present properties can still be changed as long as they are writable.\nreturn the object being sealed.\n"
  },
  "Object.setPrototypeOf()": {
    "prefix": ["ospo", "Obj.setPrototypeOf()"],
    "body": ["Object.setPrototypeOf(${1:obj}, ${2:prototype});"],
    "description": "Object.setPrototypeOf(obj, prototype);\nreturn the specified object.\n"
  },
  "Object.entries()": {
    "prefix": ["oe", "Obj.entries()"],
    "body": ["Object.entries(${1:obj})"],
    "description": "Object.entries(obj);\nreturn an array of a given object's own enumerable string-keyed property [key, value] pairs.\n"
  },
  "Object.keys()": {
    "prefix": ["ok", "Obj.keys()"],
    "body": ["Object.keys(${1:obj})"],
    "description": "Object.keys(obj);\nreturn an array of a given object's own property names, in the same order as we get with a normal loop.\n"
  },
  "Object.values()": {
    "prefix": ["ov", "Obj.values()"],
    "body": ["Object.values(${1:obj})"],
    "description": "Object.values(obj);\nreturn an array of a given object's own enumerable property values, in the same order as that provided by a for...in loop (the difference being that a for-in loop enumerates properties in the prototype chain as well).\n"
  },
  "*obj.hasOwnProperty()": {
    "prefix": ["hop", "obj.hasOwnProperty()"],
    "body": ["${1:obj}.hasOwnProperty(${2:propertyName})"],
    "description": "Object.prototype.hasOwnProperty(propertyName);\nreturn a boolean indicating whether the object has the specified property as its own property (as opposed to inheriting it).\n"
  },
  "*prototypeObj.isPrototypeOf()": {
    "prefix": ["ipo", "obj.isPrototypeOf()"],
    "body": ["${1:prototypeObj}.isPrototypeOf(${2:object})"],
    "description": "Object.prototype.isPrototypeOf(object);\nreturn a Boolean indicating whether the calling object lies in the prototype chain of the specified object.\nthrown a TypeError is thrown if 'prototypeObj' is 'undefined' or 'null'.\n"
  },
  "*obj.propertyIsEnumerable()": {
    "prefix": ["pie", "obj.propertyIsEnumerable()"],
    "body": ["${1:obj}.propertyIsEnumerable(${2:propertyName})"],
    "description": "Object.prototype.propertyIsEnumerable(propertyName);\nreturn a Boolean indicating whether the specified property is enumerable.\n"
  },
  "*obj.toLocaleString()": {
    "prefix": ["tls", "obj.toLocaleString()"],
    "body": ["${1:obj}.toLocaleString();"],
    "description": "Object.prototype.toLocaleString();\n"
  },
  "*obj.toString()": {
    "prefix": ["ts", "obj.toString()"],
    "body": ["${1:obj}.toString();"],
    "description": "Object.prototype.toString();\n"
  },
  "*obj.valueOf()": {
    "prefix": ["vo", "obj.valueOf()"],
    "body": ["${1:obj}.valueOf()"],
    "description": "Object.prototype.valueOf();\n returns the primitive value of a **Objects** object\n"
  },
  "new Promise": {
    "prefix": "pr",
    "body": ["const ${1:promise} = new Promise((resolve, reject) => {", "\t${2}", "});", ""],
    "description": "Promise\n"
  },
  "Promise.all()": {
    "prefix": "pa",
    "body": ["const results = await Promise.all([${1:promises}]);"],
    "description": "The `Promise.all()` method takes an iterable of promises as an input, and returns a single Promise that resolves to an array of the results of the input promises.\n"
  },
  "Promise.any()": {
    "prefix": "pan",
    "body": ["const result = await Promise.any([${1:promises}]);"],
    "description": "`Promise.any()` takes an iterable of Promise objects. It returns a single promise that resolves as soon as any of the promises in the iterable fulfills, with the value of the fulfilled promise. If no promises in the iterable fulfill (if all of the given promises are rejected), then the returned promise is rejected with an AggregateError, a new subclass of Error that groups together individual errors.\n"
  },
  "Promise.allSettled()": {
    "prefix": "pas",
    "body": ["const results = await Promise.allSettled([${1:promises}]);"],
    "description": "The `Promise.allSettled()` method returns a promise that resolves after all of the given promises have either fulfilled or rejected, with an array of objects that each describes the outcome of each promise.\n"
  },
  "Promise.race()": {
    "prefix": "pra",
    "body": ["const result = await Promise.race([${1:promises}]);"],
    "description": "The `Promise.race()` method returns a promise that fulfills or rejects as soon as one of the promises in an iterable fulfills or rejects, with the value or reason from that promise.\n"
  },
  "Promise.reject()": {
    "prefix": "prj",
    "body": ["Promise.reject(${1:reason})${2:;}"],
    "description": "Promise.reject\n"
  },
  "Promise.resolve()": {
    "prefix": "prs",
    "body": ["Promise.resolve(${1:value})${2:;}"],
    "description": "Promise.resolve\n"
  },
  "reject()": {
    "prefix": "rj",
    "body": ["reject(${1:reason});"],
    "description": "reject()\n"
  },
  "resolve()": {
    "prefix": "rs",
    "body": ["resolve(${1:value});"],
    "description": "resolve()\n"
  },
  "promise.catch": {
    "prefix": "pc",
    "body": ["${1:promise}.catch((error) => {", "\t${2}", "});", ""],
    "description": "promise.catch\n"
  },
  "promise.finally": {
    "prefix": "pf",
    "body": ["${1:promise}.finally(() => {", "\t${2}", "});", ""],
    "description": "promise.finally\n"
  },
  "promise.then": {
    "prefix": "pt",
    "body": ["${1:promise}.then((${2:result}) => {", "\t${3}", "});", ""],
    "description": "promise.then\n"
  },
  "promise.then.catch": {
    "prefix": "ptc",
    "body": [
      "${1:promise}.then((${2:result}) => {",
      "\t${3}",
      "}).catch((${4:error}) => {",
      "\t${5}",
      "});"
    ],
    "description": "promise.then.catch\n"
  },
  "promise.then.catch.finally": {
    "prefix": "ptcf",
    "body": [
      "${1:promise}.then((${2:result}) => {",
      "\t${3}",
      "}).catch((${4:error}) => {",
      "\t${5}",
      "}).finally(() => {",
      "\t${6}",
      "});",
      ""
    ],
    "description": "Promise.then.catch.finally\n"
  },
  "return promise": {
    "prefix": "rp",
    "body": ["return new Promise((resolve, reject) => {\n\t${1}\n});"],
    "description": "return a new Promise\n"
  },
  "proxy set": {
    "prefix": "proxy.set",
    "body": [
      "const proxy = new Proxy(${1:target}, {",
      "\tset(trapTarget, key, value, receiver) {",
      "\t\t// Overrides the Behavior Of Writing to a property",
      "\t\t// if (!trapTarget.hasOwnProperty(key)) {\t}",
      "\t\t${2}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.set(trapTarget, key, value, receiver);",
      "\t}",
      "});"
    ],
    "description": "const proxy = new Proxy(target, handler);\nValidating Properties Using the set Trap\nNicholas C. Zakas\nhttps://github.com/nzakas/understandinges6/blob/master/manuscript/12-Proxies-and-Reflection.md#validating-properties-using-the-set-trap"
  },
  "proxy get": {
    "prefix": "proxy.get",
    "body": [
      "const proxy = new Proxy(${1:target}, {",
      "\tget(trapTarget, key, receiver) {",
      "\t\t// Overrides the Behavior Of Reading a property value",
      "\t\t${2}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.get(trapTarget, key, receiver);",
      "\t}",
      "});"
    ],
    "description": "const proxy = new Proxy(target, handler);\nObject Shape Validation Using the get Trap\nNicholas C. Zakas\nhttps://github.com/nzakas/understandinges6/blob/master/manuscript/12-Proxies-and-Reflection.md#object-shape-validation-using-the-get-trap"
  },
  "proxy has": {
    "prefix": "proxy.has",
    "body": [
      "const proxy = new Proxy(${1:target}, {",
      "\thas(trapTarget, key) {",
      "\t\t// Overrides the Behavior Of The 'in' operator",
      "\t\t${2}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.has(trapTarget, key);",
      "\t}",
      "});"
    ],
    "description": "const proxy = new Proxy(target, handler);\nHiding Property Existence Using the has Trap\nNicholas C. Zakas\nhttps://github.com/nzakas/understandinges6/blob/master/manuscript/12-Proxies-and-Reflection.md#hiding-property-existence-using-the-has-trap"
  },
  "proxy delete": {
    "prefix": "proxy.delete",
    "body": [
      "const proxy = new Proxy(${1:target}, {",
      "\tdeleteProperty(trapTarget, key) {",
      "\t\t// Overrides the Behavior Of The 'delete' operator",
      "\t\t${2}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.deleteProperty(trapTarget, key);",
      "\t}",
      "});"
    ],
    "description": "const proxy = new Proxy(target, handler);\nPreventing Property Deletion with the deleteProperty Trap\nNicholas C. Zakas\nhttps://github.com/nzakas/understandinges6/blob/master/manuscript/12-Proxies-and-Reflection.md#preventing-property-deletion-with-the-deleteproperty-trap"
  },
  "proxy prototype": {
    "prefix": "proxy.prototype",
    "body": [
      "const proxy = new Proxy(${1:target}, {",
      "\tgetPrototypeOf(trapTarget) {",
      "\t\t// Overrides the Behavior Of 'Object.getPrototypeOf()'",
      "\t\t${2}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.getPrototypeOf(trapTarget);",
      "\t},",
      "\t\tsetPrototypeOf(trapTarget, proto) {",
      "\t\t// Overrides the Behavior Of 'Object.setPrototypeOf()'",
      "\t\t${3}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.setPrototypeOf(trapTarget, proto);",
      "\t}",
      "});"
    ],
    "description": "const proxy = new Proxy(target, handler);\nPrototype Proxy Traps\nNicholas C. Zakas\nhttps://github.com/nzakas/understandinges6/blob/master/manuscript/12-Proxies-and-Reflection.md#prototype-proxy-traps"
  },
  "proxy object extensibility": {
    "prefix": "proxy.extensibility",
    "body": [
      "const proxy = new Proxy(${1:target}, {",
      "\tisExtensible(trapTarget) {",
      "\t\t// Overrides the Behavior Of 'Object.isExtensible()'",
      "\t\t${2}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.isExtensible(trapTarget);",
      "\t},",
      "\tpreventExtensions(trapTarget) {",
      "\t\t// Overrides the Behavior Of 'Object.preventExtensions()'",
      "\t\t${3}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.preventExtensions(trapTarget);",
      "\t}",
      "});"
    ],
    "description": "const proxy = new Proxy(target, handler);\nObject Extensibility Traps\nNicholas C. Zakas\nhttps://github.com/nzakas/understandinges6/blob/master/manuscript/12-Proxies-and-Reflection.md#object-extensibility-traps"
  },
  "proxy object property descriptor ": {
    "prefix": "proxy.property",
    "body": [
      "const proxy = new Proxy(${1:target}, {",
      "\tdefineProperty(trapTarget, key, descriptor) {",
      "\t\t// Overrides the Behavior Of 'Object.defineProperty()'",
      "\t\t${2}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.defineProperty(trapTarget, key, descriptor);",
      "\t},",
      "\tgetOwnPropertyDescriptor(trapTarget, key) {",
      "\t\t// Overrides the Behavior Of 'Object.getOwnPropertyDescriptor()'",
      "\t\t${3}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.getOwnPropertyDescriptor(trapTarget, key);",
      "\t}",
      "});"
    ],
    "description": "const proxy = new Proxy(target, handler);\nProperty Descriptor Traps\nNicholas C. Zakas\nhttps://github.com/nzakas/understandinges6/blob/master/manuscript/12-Proxies-and-Reflection.md#property-descriptor-traps"
  },
  "proxy ownKeys": {
    "prefix": "proxy.ownKeys",
    "body": [
      "const proxy = new Proxy(${1:target}, {",
      "\townKeys(trapTarget) {",
      "\t\t// Overrides the Behavior Of",
      "\t\t// - 'Object.keys'",
      "\t\t// - 'Object.getOwnPropertyNames()'",
      "\t\t// - 'Object.getOwnPropertySymbols()'",
      "\t\t${2}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.ownKeys(trapTarget);",
      "\t}",
      "});"
    ],
    "description": "const proxy = new Proxy(target, handler);\nThe ownKeys Trap\nNicholas C. Zakas\nhttps://github.com/nzakas/understandinges6/blob/master/manuscript/12-Proxies-and-Reflection.md#the-ownkeys-trap"
  },
  "proxy function": {
    "prefix": "proxy.function",
    "body": [
      "const proxy = new Proxy(${1:target}, {",
      "\tapplay(trapTarget, thisArg, argumentsList) {",
      "\t\t// Overrides the Behavior Of Calling a function",
      "\t\t${2}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.applay(trapTarget, thisArg, argumentsList);",
      "\t},",
      "\tconstruct(trapTarget, argumentsList) {",
      "\t\t// Overrides the Behavior Of Calling a function with new",
      "\t\t${3}",
      "\t\t// Default Behavior",
      "\t\treturn Reflect.construct(trapTarget, argumentsList);",
      "\t}",
      "});"
    ],
    "description": "const proxy = new Proxy(target, handler);\nFunction Proxies with the apply and construct Traps\nNicholas C. Zakas\nhttps://github.com/nzakas/understandinges6/blob/master/manuscript/12-Proxies-and-Reflection.md#function-proxies-with-the-apply-and-construct-traps"
  },
  "Revocable Proxies": {
    "prefix": "proxy.revocable",
    "body": ["const { proxy, revoke } = Proxy.revocable(${1:target}, {})"],
    "description": "Proxy.revocable(target, handler);\nRevocable Proxies\nNicholas C. Zakas\nhttps://github.com/nzakas/understandinges6/blob/master/manuscript/12-Proxies-and-Reflection.md#revocable-proxies"
  },
  "RegExp(pattern[, flags])": {
    "prefix": "re",
    "body": ["const ${1:regexp} = RegExp('${2:pattern}');"],
    "description": "RegExp(pattern[, flags])"
  },
  "/pattern/flags": {
    "prefix": "rep",
    "body": ["const ${1:regexp} = /${2:pattern}/;"],
    "description": "/pattern/flags\nliteral notation's"
  },
  "RegExp.prototype.exec()": {
    "prefix": ["ree", "re.exec()"],
    "body": [
      "const ${1:regexp} = RegExp('${2:pattern}');",
      "const ${3:result} = ${1}.exec(${4:str});"
    ],
    "description": "Syntax: regexp.exec(str)\nexecutes a search for a match in a specified string.\nreturn a result array, or **null**."
  },
  "RegExp.prototype.test()": {
    "prefix": ["ret", "re.test()"],
    "body": [
      "const ${1:regexp} = RegExp('${2:pattern}');",
      "const ${3:result} = ${1}.test(${4:str});"
    ],
    "description": "Syntax: regexp.test(str)\nexecutes a search for a match between a regular expression and a specified string. \nreturn **true** or **false**."
  },
  "get RegExp[@@species]": {
    "prefix": "re.@@species",
    "body": [
      "class FeatureRegExp extends RegExp {",
      "\tstatic get [Symbol.species]() {",
      "\t\treturn RegExp;",
      "\t}",
      "}"
    ],
    "description": "Syntax: RegExp[Symbol.species]\nThe RegExp[@@species] accessor property returns the RegExp constructor."
  },
  "RegExp.prototype[@@match]()": {
    "prefix": "re.@@match",
    "body": [
      "class FeatureRegExp extends RegExp {",
      "\t[Symbol.match](str) {",
      "\t\tconst result = RegExp.prototype[Symbol.match].call(this, str);",
      "\t\tif (result) {",
      "\t\t\treturn 'VALID';",
      "\t\t}",
      "\t\treturn 'INVALID';",
      "\t}",
      "}"
    ],
    "description": "Syntax: regexp[Symbol.match](str)\nThe [@@match]() method retrieves the matches when matching a string against a regular expression."
  },
  "RegExp.prototype[@@matchAll]()": {
    "prefix": "re.@@matchAll",
    "body": [
      "class FeatureRegExp extends RegExp {",
      "\t[Symbol.matchAll](str) {",
      "\t\tconst result = RegExp.prototype[Symbol.matchAll].call(this, str);",
      "\t\tif (!result) {",
      "\t\t\treturn null;",
      "\t\t}",
      "\t\treturn Array.from(result);",
      "\t}",
      "}"
    ],
    "description": "Syntax: regexp[Symbol.matchAll](str)\nThe [@@matchAll] method returns all matches of the regular expression against a string."
  },
  "RegExp.prototype[@@replace]()": {
    "prefix": "re.@@replace",
    "body": [
      "class FeatureRegExp extends RegExp {",
      "\t[Symbol.replace](str) {",
      "\t\treturn RegExp.prototype[Symbol.replace].call(this, str, '#!@?');",
      "\t}",
      "}"
    ],
    "description": "Syntax: regexp[Symbol.replace](str, newSubStr|function)\nThe [@@replace]() method replaces some or all matches of a this pattern in a string by a replacement, and returns the result of the replacement as a new string. The replacement can be a string or a function to be called for each match."
  },
  "RegExp.prototype[@@search]()": {
    "prefix": "re.@@search",
    "body": [
      "class FeatureRegExp extends RegExp {",
      "\tconstructor(str) {",
      "\t\tsuper(str);",
      "\t\tthis.pattern = str;",
      "\t}",
      "\t[Symbol.search](str) {",
      "\t\treturn str.indexOf(this.pattern);",
      "\t}",
      "}"
    ],
    "description": "Syntax: regexp[Symbol.search](str)\nThe [@@search]() method executes a search for a match between a this regular expression and a string."
  },
  "RegExp.prototype[@@split]()": {
    "prefix": "re.@@split",
    "body": [
      "class FeatureRegExp extends RegExp {",
      "\t[Symbol.split](str, limit) {",
      "\t\tconst result = RegExp.prototype[Symbol.split].call(this, str, limit);",
      "\t\treturn result.map(x => `(${1:x})`);",
      "\t}",
      "}"
    ],
    "description": "Syntax: regexp[Symbol.split](str[, limit])\nThe [@@split]() method splits a String object into an array of strings by separating the string into substrings."
  },
  "if": {
    "prefix": "if",
    "body": ["if (${1}) {\n\t${2}\n}"],
    "description": "if statement \n"
  },
  "if/else": {
    "prefix": "ife",
    "body": ["if (${1}) {\n\t${2}\n} else {\n\t${3}\n}"],
    "description": "if/else statement \n"
  },
  "else if": {
    "prefix": "ei",
    "body": ["else if (${1}) {\n\t${2}\n}"],
    "description": "else if statement \n"
  },
  "else": {
    "prefix": "el",
    "body": ["else {\n\t${1}\n}"],
    "description": "else statement \n"
  },
  "switch": {
    "prefix": "swi",
    "body": [
      "switch (${1:expression}) {\n\tcase '${2:value}':\n\t\t${3}\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n}"
    ],
    "description": "switch statement\n"
  },
  "case": {
    "prefix": "cas",
    "body": ["case ${1:value}:\n\t${2}\n\t\tbreak;"],
    "description": "switch's case statement \n"
  },
  "for-in": {
    "prefix": "fin",
    "body": [
      "for (let ${1:property} in ${2:object}) {\n\tif (${2:object}.hasOwnProperty(${1:property})) {\n\t\t${3}\n\t}\n}"
    ],
    "description": "The for...in statement iterates over all enumerable properties of an object that are keyed by strings (ignoring ones keyed by Symbols), including inherited enumerable properties.\n"
  },
  "for-of": {
    "prefix": "fof",
    "body": ["for (let ${1:variable} of ${2:iterable}) {\n\t${3}\n}"],
    "description": "The for...of statement creates a loop iterating over iterable objects, including: built-in String, Array, array-like objects (e.g., arguments or NodeList), TypedArray, Map, Set, and user-defined iterables. It invokes a custom iteration hook with statements to be executed for the value of each distinct property of the object.\n"
  },
  "for loop iterable": {
    "prefix": ["fl", "fo", "for"],
    "body": [
      "for (let ${1:index} = 0, ${2:length} = ${3:iterable}.length; ${1:index} < ${2:length}; ${1:index} += 1) {\n\tconst element = ${3}[${1}];\n\t${4}\n}"
    ],
    "description": "for loop iterable\n"
  },
  "for loop iterable(reverse)": {
    "prefix": ["flr", "forr"],
    "body": [
      "for (let ${1:index} = ${2:iterable}.length - 1; ${1:index} >= 0; ${1:index} -= 1) {\n\tconst element = ${2}[${1}];\n\t${4}\n}"
    ],
    "description": "reverse for loop iterable\n"
  },
  "while iteration": {
    "prefix": "wh",
    "body": ["while (${1:condition}) {\n\t${2}\n}"],
    "description": "while iteration\n"
  },
  "while iteration decrementing": {
    "prefix": "whi",
    "body": [
      "let ${1:iterable}Index = ${1:array}.length\nwhile (${1:iterableIndex}Index--) {\n\t${2}\n}"
    ],
    "description": "while iteration decrementing\n"
  },
  "Template literals": {
    "prefix": "tl",
    "body": ["$2`\\${${1:expression}\\}$3`"],
    "description": "Template strings\n"
  },
  "String.prototype.length": {
    "prefix": ["sl", "str.length"],
    "body": ["${1:str}.length"],
    "description": "String.prototype.length\nreturns the number of code units in the string.\n"
  },
  "String.fromCharCode()": {
    "prefix": ["sfcc", "Str.fromCharCode()"],
    "body": ["String.fromCharCode(${1:numN})"],
    "description": "String.fromCharCode(num1[, ...[, numN]])\nreturn a string created from the specified sequence of UTF-16 code units.\n"
  },
  "String.fromCodePoint()": {
    "prefix": ["sfcp", "Str.fromCodePoint()"],
    "body": ["String.fromCodePoint(${1:numN})"],
    "description": "String.fromCodePoint(num1[, ...[, numN]])\nreturn a string created by using the specified sequence of code points.\na RangeError is thrown if an invalid Unicode code point is given (e.g. 'RangeError: NaN is not a valid code point').\n"
  },
  "String.raw()": {
    "prefix": ["sr", "Str.raw()"],
    "body": ["String.raw`${1:templateString}`"],
    "description": "String.raw(callSite, ...substitutions)|String.raw`templateString`\nreturn the raw string form of a given template string.\n"
  },
  "String.prototype.charAt()": {
    "prefix": ["sca", "str.charAt()"],
    "body": ["${1:str}.charAt(${2:index})"],
    "description": "str.charAt(index)\n returns a new string consisting of the single UTF-16 code unit located at the specified offset into the string.\n"
  },
  "String.prototype.charCodeAt()": {
    "prefix": ["scca", "str.charCodeAt()"],
    "body": ["${1:str}.charCodeAt(${2:index})"],
    "description": "str.charCodeAt(index)\nreturn an integer between 0 and 65535 representing the UTF-16 code unit at the given index.\n"
  },
  "String.prototype.codePointAt()": {
    "prefix": ["scpa", "str.codePointAt()"],
    "body": ["${1:str}.codePointAt(${2:position})"],
    "description": "str.codePointAt(pos)\nreturn a non-negative integer that is the Unicode code point value.\n"
  },
  "String.prototype.concat()": {
    "prefix": ["sc", "str.concat()"],
    "body": ["${1:str}.concat(${2:stringN})"],
    "description": "str.concat(string2[, string3, ..., stringN])\nreturn a new string containing the combined text of the strings provided.\n"
  },
  "String.prototype.endsWith()": {
    "prefix": ["sew", "str.endsWith()"],
    "body": ["${1:str}.endsWith(${2:searchString})"],
    "description": "str.endsWith(searchString[, length])\nreturn 'true' if the given characters are found at the end of the string; otherwise, 'false'.\n"
  },
  "String.prototype.includes()": {
    "prefix": ["sin", "str.includes()"],
    "body": ["${1:str}.includes(${2:searchString})"],
    "description": "str.includes(searchString[, position])\nreturn 'true' if the search string is found anywhere within the given string; otherwise, 'false' if not.\n"
  },
  "String.prototype.indexOf()": {
    "prefix": ["sio", "str.indexOf()"],
    "body": ["${1:str}.indexOf(${2:searchValue})"],
    "description": "str.indexOf(searchValue[, fromIndex])\nreturn the index of the first occurrence of searchValue, or '-1' if not found.\nAn empty string searchValue will match at any index between '0' and str.length\n"
  },
  "String.prototype.lastIndexOf()": {
    "prefix": ["slio", "str.lastIndexOf()"],
    "body": ["${1:str}.lastIndexOf(${2:searchValue})"],
    "description": "str.lastIndexOf(searchValue[, fromIndex])\nreturn the index of the last occurrence of the specified value; '-1' if not found.\n"
  },
  "String.prototype.localeCompare()": {
    "prefix": ["slc", "str.localeCompare()"],
    "body": ["${1:str}.localeCompare(${2:compareString})"],
    "description": "referenceStr.localeCompare(compareString[, locales[, options]])\nreturn a **negative** number if the reference string occurs before the compare string; **positive** if the reference string occurs after the compare string; **0** if they are equivalent.\n"
  },
  "String.prototype.match()": {
    "prefix": ["sm", "str.match()"],
    "body": ["${1:str}.match(${2:regexp})"],
    "description": "str.match(regexp)\nreturn an **Array** whose contents depend on the presence or absence of the global (**g**) flag, or **null** if no matches are found.\n"
  },
  "String.prototype.matchAll()": {
    "prefix": ["sma", "str.matchAll()"],
    "body": ["${1:str}.matchAll(${2:regexp})"],
    "description": "str.matchAll(regexp)\nreturn an iterator of all results matching a string against a regular expression, including capturing groups.\n"
  },
  "String.prototype.normalize()": {
    "prefix": ["sn", "str.normalize()"],
    "body": ["${1:str}.normalize('${2:NFC}')"],
    "description": "str.normalize([form])\n**form**\n- NFC — Normalization Form Canonical Composition.\n- NFD — Normalization Form Canonical Decomposition.\n- NFKC — Normalization Form Compatibility Composition.\n- NFKD — Normalization Form Compatibility Decomposition.\nreturn the Unicode Normalization Form of a given string (if the value isn't a string, it will be converted to one first).\n thrown a **RangeError** is thrown if **form** isn't one of the values specified above.\n"
  },
  "String.prototype.padEnd()": {
    "prefix": ["spe", "str.padEnd()"],
    "body": ["${1:str}.padEnd(${2:targetLength}, ${3:padString})"],
    "description": "str.padEnd(targetLength [, padString])\nreturn a **String** of the specified length with the pad string applied at the end of the current string.\n"
  },
  "String.prototype.padStart()": {
    "prefix": ["sps", "str.padStart()"],
    "body": ["${1:str}.padStart(${2:targetLength}, ${3:padString})"],
    "description": "str.padStart(targetLength [, padString])\nreturn a **String** of the specified length with the pad string applied from the start.\n"
  },
  "String.prototype.repeat()": {
    "prefix": ["sr", "str.repeat()"],
    "body": ["${1:str}.repeat(${2:count})"],
    "description": "str.repeat(count)\nreturn a new string containing the specified number of copies of the given string.\n"
  },
  "String.prototype.replace()": {
    "prefix": ["sre", "str.replace()"],
    "body": ["${1:str}.replace(${2:regexp}, ${3:newSubStr})"],
    "description": "str.replace(regexp|substr, newSubStr|function)\nreturn a new string with some or all matches of a **pattern** replaced by a **replacement**. The **pattern** can be a string or a **RegExp**, and the **replacement** can be a string or a function to be called for each match. If **pattern** is a string, only the first occurrence will be replaced.\nThe original string is left unchanged.\n"
  },
  "String.prototype.search()": {
    "prefix": ["ss", "str.search()"],
    "body": ["${1:str}.search(${2:regexp})"],
    "description": "str.search(regexp)\nreturn the index of the first match between the regular expression and the given string; if not found, **-1**.\n"
  },
  "String.prototype.slice()": {
    "prefix": ["ssl", "str.slice()"],
    "body": ["${1:str}.slice(${2:beginIndex}, ${3:endIndex})"],
    "description": "str.slice(beginIndex[, endIndex])\nreturn a new string containing the extracted section of the string.\n"
  },
  "String.prototype.split()": {
    "prefix": ["ssp", "str.split()"],
    "body": ["${1:str}.split(${2:separator})"],
    "description": "str.split([separator[, limit]])\nreturn an Array of strings split at each point where the separator occurs in the given string.\n"
  },
  "String.prototype.startsWith()": {
    "prefix": ["ssw", "str.startsWith()"],
    "body": ["${1:str}.startsWith(${2:searchString}, ${3:position})"],
    "description": "str.startsWith(searchString[, position])\nreturn **true** if the given characters are found at the beginning of the string; otherwise, **false**.\n"
  },
  "String.prototype.substring()": {
    "prefix": ["sss", "str.substring()"],
    "body": ["${1:str}.substring(${2:indexStart}, ${3:indexEnd})"],
    "description": "str.substring(indexStart[, indexEnd])\nreturn the part of the string between the start and end indexes, or to the end of the string.\n"
  },
  "String.prototype.toLocaleLowerCase()": {
    "prefix": ["stllc", "str.toLocaleLowerCase()"],
    "body": ["${1:str}.toLocaleLowerCase()"],
    "description": "str.toLocaleLowerCase([locale, locale, ...])\nreturn a new string representing the calling string converted to lower case, according to any locale-specific case mappings.\n"
  },
  "String.prototype.toLocaleUpperCase()": {
    "prefix": ["stluc", "str.toLocaleUpperCase()"],
    "body": ["${1:str}.toLocaleUpperCase()"],
    "description": "str.toLocaleUpperCase([locale, locale, ...])\nreturn a new string representing the calling string converted to upper case, according to any locale-specific case mappings.\n"
  },
  "String.prototype.toLowerCase()": {
    "prefix": ["stlc", "str.toLowerCase()"],
    "body": ["${1:str}.toLowerCase()"],
    "description": "str.toLowerCase()\nreturn a new string representing the calling string converted to lower case.\n"
  },
  "String.prototype.toUpperCase()": {
    "prefix": ["stuc", "str.toUpperCase()"],
    "body": ["${1:str}.toUpperCase()"],
    "description": "str.toUpperCase()\nreturn a new string representing the calling string converted to upper case.\n"
  },
  "String.prototype.trim()": {
    "prefix": ["str", "str.trim()"],
    "body": ["${1:str}.trim()"],
    "description": "str.trim()\nreturn a new string representing the calling string stripped of whitespace from both ends.\n"
  },
  "String.prototype.trimEnd()": {
    "prefix": ["ste", "str.trimEnd()"],
    "body": ["${1:str}.trimEnd() //trimRight()"],
    "description": "str.trimEnd()/trimRight()\nreturn a new string representing the calling string stripped of whitespace from its (right) end.\n"
  },
  "String.prototype.trimStart()": {
    "prefix": ["sts", "str.trimStart()"],
    "body": ["${1:str}.trimStart() //trimLeft()"],
    "description": "str.trimStart()/trimLeft()\nreturn a new string representing the calling string stripped of whitespace from its beginning (left end).\n"
  },
  "String.prototype[@@iterator]()": {
    "prefix": "ssi",
    "body": ["const ${2:iterator} = ${1:str}[Symbol.iterator]();", "$2.next().value"],
    "description": "str[Symbol.iterator]\nreturn a new **Iterator** object.\n"
  },
  "const Symbol": {
    "prefix": ["csy", "sym"],
    "body": ["const ${1:symObj} = Symbol();"],
    "description": "const assignment Symbol"
  },
  "Symbol.for": {
    "prefix": "symf",
    "body": ["Symbol.for('${1:key}');"],
    "description": "The `Symbol.for(key)` method searches for existing symbols in a runtime-wide symbol registry with the given key and returns it if found. Otherwise a new symbol gets created in the global symbol registry with this key."
  },
  "Symbol.keyFor": {
    "prefix": "symk",
    "body": ["Symbol.keyFor('${1:symObj}');"],
    "description": "The `Symbol.keyFor(sym)` method retrieves a shared symbol key from the global symbol registry for the given symbol."
  },
  "test suite: describe": {
    "prefix": ["desc", "test.describe"],
    "body": ["describe('${1:description}', () => {", "\t${2}", "})"],
    "description": "test suite: describe\n"
  },
  "test suite: context": {
    "prefix": ["cont", "test.context"],
    "body": ["context('${1:description}', ${2:callback});${0}"],
    "description": "test suite: context\n"
  },
  "test suite: it synchronous": {
    "prefix": ["it", "test.it"],
    "body": ["it('${1:description}', () => {", "\t${2}", "})"],
    "description": "test suite: it synchronous\n"
  },
  "test suite: it asynchronous": {
    "prefix": ["itas", "test.itas"],
    "body": ["it('${1:description}', async (done) => {", "\t${2}", "\tdone();", "});${0}"],
    "description": "test suite: it asynchronous\n"
  },
  "test suite: afterEach": {
    "prefix": ["afe", "test.afterEach"],
    "body": ["afterEach(() => {", "\t${1}", "})"],
    "description": "test suite: afterEach\n"
  },
  "test suite: beforeEach": {
    "prefix": ["bfe", "test.beforeEach"],
    "body": ["beforeEach(() => {", "\t${1}", "})"],
    "description": "test suite: beforeEach\n"
  },
  "test suite: after": {
    "prefix": ["aft", "test.after"],
    "body": ["after(() => {", "\t${1}", "})"],
    "description": "test suite: after\n"
  },
  "test suite: before": {
    "prefix": ["bf", "test.before"],
    "body": ["before(() => {", "\t${1}", "})"],
    "description": "test suite: before\n"
  }
}
